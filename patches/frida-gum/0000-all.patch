From ac023d0fe7efba68b73ebf3c914120771d5f7a63 Mon Sep 17 00:00:00 2001
From: 456vv <123@456vv.com>
Date: Sat, 21 Dec 2024 01:06:39 +0800
Subject: [PATCH] all

---
 bindings/gumjs/generate-runtime.py  | 4 ++++
 bindings/gumjs/gumscriptscheduler.c | 2 +-
 gum/gum.c                           | 2 +-
 3 files changed, 6 insertions(+), 2 deletions(-)

diff --git a/bindings/gumjs/generate-runtime.py b/bindings/gumjs/generate-runtime.py
index 0b58a0f..057ff7c 100644
--- a/bindings/gumjs/generate-runtime.py
+++ b/bindings/gumjs/generate-runtime.py
@@ -56,6 +56,10 @@ def generate_runtime(output_dir, priv_dir, input_dir, gum_dir, capstone_incdir,
                        capture_output=True,
                        cwd=priv_dir,
                        check=True)
+        js_dir = priv_dir / "node_modules" / "frida-java-bridge" / "lib" 
+        (js_dir / "android.js").write_text("const makeCodeAllocator = require('./alloc');\nconst {\n  jvmtiVersion,\n  jvmtiCapabilities,\n  EnvJvmti\n} = require('./jvmti');\nconst { parseInstructionsAt } = require('./machine-code');\nconst memoize = require('./memoize');\nconst { checkJniResult, JNI_OK } = require('./result');\nconst VM = require('./vm');\n\nconst jsizeSize = 4;\nconst pointerSize = Process.pointerSize;\n\nconst {\n  readU32,\n  readPointer,\n  writeU32,\n  writePointer\n} = NativePointer.prototype;\n\nconst kAccPublic = 0x0001;\nconst kAccStatic = 0x0008;\nconst kAccFinal = 0x0010;\nconst kAccNative = 0x0100;\nconst kAccFastNative = 0x00080000;\nconst kAccCriticalNative = 0x00200000;\nconst kAccFastInterpreterToInterpreterInvoke = 0x40000000;\nconst kAccSkipAccessChecks = 0x00080000;\nconst kAccSingleImplementation = 0x08000000;\nconst kAccNterpEntryPointFastPathFlag = 0x00100000;\nconst kAccNterpInvokeFastPathFlag = 0x00200000;\nconst kAccPublicApi = 0x10000000;\nconst kAccXposedHookedMethod = 0x10000000;\n\nconst kPointer = 0x0;\n\nconst kFullDeoptimization = 3;\nconst kSelectiveDeoptimization = 5;\n\nconst THUMB_BIT_REMOVAL_MASK = ptr(1).not();\n\nconst X86_JMP_MAX_DISTANCE = 0x7fffbfff;\nconst ARM64_ADRP_MAX_DISTANCE = 0xfffff000;\n\nconst ENV_VTABLE_OFFSET_EXCEPTION_CLEAR = 17 * pointerSize;\nconst ENV_VTABLE_OFFSET_EXCEPTION_CLEAR_ALT = 250 * pointerSize;\nconst ENV_VTABLE_OFFSET_FATAL_ERROR = 18 * pointerSize;\n\nconst DVM_JNI_ENV_OFFSET_SELF = 12;\n\nconst DVM_CLASS_OBJECT_OFFSET_VTABLE_COUNT = 112;\nconst DVM_CLASS_OBJECT_OFFSET_VTABLE = 116;\n\nconst DVM_OBJECT_OFFSET_CLAZZ = 0;\n\nconst DVM_METHOD_SIZE = 56;\nconst DVM_METHOD_OFFSET_ACCESS_FLAGS = 4;\nconst DVM_METHOD_OFFSET_METHOD_INDEX = 8;\nconst DVM_METHOD_OFFSET_REGISTERS_SIZE = 10;\nconst DVM_METHOD_OFFSET_OUTS_SIZE = 12;\nconst DVM_METHOD_OFFSET_INS_SIZE = 14;\nconst DVM_METHOD_OFFSET_SHORTY = 28;\nconst DVM_METHOD_OFFSET_JNI_ARG_INFO = 36;\n\nconst DALVIK_JNI_RETURN_VOID = 0;\nconst DALVIK_JNI_RETURN_FLOAT = 1;\nconst DALVIK_JNI_RETURN_DOUBLE = 2;\nconst DALVIK_JNI_RETURN_S8 = 3;\nconst DALVIK_JNI_RETURN_S4 = 4;\nconst DALVIK_JNI_RETURN_S2 = 5;\nconst DALVIK_JNI_RETURN_U2 = 6;\nconst DALVIK_JNI_RETURN_S1 = 7;\nconst DALVIK_JNI_NO_ARG_INFO = 0x80000000;\nconst DALVIK_JNI_RETURN_SHIFT = 28;\n\nconst STD_STRING_SIZE = 3 * pointerSize;\nconst STD_VECTOR_SIZE = 3 * pointerSize;\n\nconst AF_UNIX = 1;\nconst SOCK_STREAM = 1;\n\nconst getArtRuntimeSpec = memoize(_getArtRuntimeSpec);\nconst getArtInstrumentationSpec = memoize(_getArtInstrumentationSpec);\nconst getArtMethodSpec = memoize(_getArtMethodSpec);\nconst getArtThreadSpec = memoize(_getArtThreadSpec);\nconst getArtManagedStackSpec = memoize(_getArtManagedStackSpec);\nconst getArtThreadStateTransitionImpl = memoize(_getArtThreadStateTransitionImpl);\nconst getAndroidVersion = memoize(_getAndroidVersion);\nconst getAndroidCodename = memoize(_getAndroidCodename);\nconst getAndroidApiLevel = memoize(_getAndroidApiLevel);\nconst getArtQuickFrameInfoGetterThunk = memoize(_getArtQuickFrameInfoGetterThunk);\n\nconst makeCxxMethodWrapperReturningPointerByValue =\n    (Process.arch === 'ia32')\n      ? makeCxxMethodWrapperReturningPointerByValueInFirstArg\n      : makeCxxMethodWrapperReturningPointerByValueGeneric;\n\nconst nativeFunctionOptions = {\n  exceptions: 'propagate'\n};\n\nconst artThreadStateTransitions = {};\n\nlet cachedApi = null;\nlet cachedArtClassLinkerSpec = null;\nlet MethodMangler = null;\nlet artController = null;\nconst inlineHooks = [];\nconst patchedClasses = new Map();\nconst artQuickInterceptors = [];\nlet thunkPage = null;\nlet thunkOffset = 0;\nlet taughtArtAboutReplacementMethods = false;\nlet taughtArtAboutMethodInstrumentation = false;\nlet backtraceModule = null;\nconst jdwpSessions = [];\nlet socketpair = null;\n\nlet trampolineAllocator = null;\n\nfunction getApi () {\n  if (cachedApi === null) {\n    cachedApi = _getApi();\n  }\n  return cachedApi;\n}\n\nfunction _getApi () {\n  const vmModules = Process.enumerateModules()\n    .filter(m => /^lib(art|dvm).so$/.test(m.name))\n    .filter(m => !/\/system\/fake-libs/.test(m.path));\n  if (vmModules.length === 0) {\n    return null;\n  }\n  const vmModule = vmModules[0];\n\n  const flavor = (vmModule.name.indexOf('art') !== -1) ? 'art' : 'dalvik';\n  const isArt = flavor === 'art';\n\n  const temporaryApi = {\n    module: vmModule,\n    flavor,\n    addLocalReference: null\n  };\n\n  const pending = isArt\n    ? [{\n        module: vmModule.path,\n        functions: {\n          JNI_GetCreatedJavaVMs: ['JNI_GetCreatedJavaVMs', 'int', ['pointer', 'int', 'pointer']],\n\n          // Android < 7\n          artInterpreterToCompiledCodeBridge: function (address) {\n            this.artInterpreterToCompiledCodeBridge = address;\n          },\n\n          // Android >= 8\n          _ZN3art9JavaVMExt12AddGlobalRefEPNS_6ThreadENS_6ObjPtrINS_6mirror6ObjectEEE: ['art::JavaVMExt::AddGlobalRef', 'pointer', ['pointer', 'pointer', 'pointer']],\n          // Android >= 6\n          _ZN3art9JavaVMExt12AddGlobalRefEPNS_6ThreadEPNS_6mirror6ObjectE: ['art::JavaVMExt::AddGlobalRef', 'pointer', ['pointer', 'pointer', 'pointer']],\n          // Android < 6: makeAddGlobalRefFallbackForAndroid5() needs these:\n          _ZN3art17ReaderWriterMutex13ExclusiveLockEPNS_6ThreadE: ['art::ReaderWriterMutex::ExclusiveLock', 'void', ['pointer', 'pointer']],\n          _ZN3art17ReaderWriterMutex15ExclusiveUnlockEPNS_6ThreadE: ['art::ReaderWriterMutex::ExclusiveUnlock', 'void', ['pointer', 'pointer']],\n\n          // Android <= 7\n          _ZN3art22IndirectReferenceTable3AddEjPNS_6mirror6ObjectE: function (address) {\n            this['art::IndirectReferenceTable::Add'] = new NativeFunction(address, 'pointer', ['pointer', 'uint', 'pointer'], nativeFunctionOptions);\n          },\n          // Android > 7\n          _ZN3art22IndirectReferenceTable3AddENS_15IRTSegmentStateENS_6ObjPtrINS_6mirror6ObjectEEE: function (address) {\n            this['art::IndirectReferenceTable::Add'] = new NativeFunction(address, 'pointer', ['pointer', 'uint', 'pointer'], nativeFunctionOptions);\n          },\n\n          // Android >= 7\n          _ZN3art9JavaVMExt12DecodeGlobalEPv: function (address) {\n            let decodeGlobal;\n            if (getAndroidApiLevel() >= 26) {\n              // Returns ObjPtr<mirror::Object>\n              decodeGlobal = makeCxxMethodWrapperReturningPointerByValue(address, ['pointer', 'pointer']);\n            } else {\n              // Returns mirror::Object *\n              decodeGlobal = new NativeFunction(address, 'pointer', ['pointer', 'pointer'], nativeFunctionOptions);\n            }\n            this['art::JavaVMExt::DecodeGlobal'] = function (vm, thread, ref) {\n              return decodeGlobal(vm, ref);\n            };\n          },\n          // Android >= 6\n          _ZN3art9JavaVMExt12DecodeGlobalEPNS_6ThreadEPv: ['art::JavaVMExt::DecodeGlobal', 'pointer', ['pointer', 'pointer', 'pointer']],\n\n          // makeDecodeGlobalFallback() uses:\n          // Android >= 15\n          _ZNK3art6Thread19DecodeGlobalJObjectEP8_jobject: ['art::Thread::DecodeJObject', 'pointer', ['pointer', 'pointer']],\n          // Android < 6\n          _ZNK3art6Thread13DecodeJObjectEP8_jobject: ['art::Thread::DecodeJObject', 'pointer', ['pointer', 'pointer']],\n\n          // Android >= 6\n          _ZN3art10ThreadList10SuspendAllEPKcb: ['art::ThreadList::SuspendAll', 'void', ['pointer', 'pointer', 'bool']],\n          // or fallback:\n          _ZN3art10ThreadList10SuspendAllEv: function (address) {\n            const suspendAll = new NativeFunction(address, 'void', ['pointer'], nativeFunctionOptions);\n            this['art::ThreadList::SuspendAll'] = function (threadList, cause, longSuspend) {\n              return suspendAll(threadList);\n            };\n          },\n\n          _ZN3art10ThreadList9ResumeAllEv: ['art::ThreadList::ResumeAll', 'void', ['pointer']],\n\n          // Android >= 7\n          _ZN3art11ClassLinker12VisitClassesEPNS_12ClassVisitorE: ['art::ClassLinker::VisitClasses', 'void', ['pointer', 'pointer']],\n          // Android < 7\n          _ZN3art11ClassLinker12VisitClassesEPFbPNS_6mirror5ClassEPvES4_: function (address) {\n            const visitClasses = new NativeFunction(address, 'void', ['pointer', 'pointer', 'pointer'], nativeFunctionOptions);\n            this['art::ClassLinker::VisitClasses'] = function (classLinker, visitor) {\n              visitClasses(classLinker, visitor, NULL);\n            };\n          },\n\n          _ZNK3art11ClassLinker17VisitClassLoadersEPNS_18ClassLoaderVisitorE: ['art::ClassLinker::VisitClassLoaders', 'void', ['pointer', 'pointer']],\n\n          _ZN3art2gc4Heap12VisitObjectsEPFvPNS_6mirror6ObjectEPvES5_: ['art::gc::Heap::VisitObjects', 'void', ['pointer', 'pointer', 'pointer']],\n          _ZN3art2gc4Heap12GetInstancesERNS_24VariableSizedHandleScopeENS_6HandleINS_6mirror5ClassEEEiRNSt3__16vectorINS4_INS5_6ObjectEEENS8_9allocatorISB_EEEE: ['art::gc::Heap::GetInstances', 'void', ['pointer', 'pointer', 'pointer', 'int', 'pointer']],\n\n          // Android >= 9\n          _ZN3art2gc4Heap12GetInstancesERNS_24VariableSizedHandleScopeENS_6HandleINS_6mirror5ClassEEEbiRNSt3__16vectorINS4_INS5_6ObjectEEENS8_9allocatorISB_EEEE: function (address) {\n            const getInstances = new NativeFunction(address, 'void', ['pointer', 'pointer', 'pointer', 'bool', 'int', 'pointer'], nativeFunctionOptions);\n            this['art::gc::Heap::GetInstances'] = function (instance, scope, hClass, maxCount, instances) {\n              const useIsAssignableFrom = 0;\n              getInstances(instance, scope, hClass, useIsAssignableFrom, maxCount, instances);\n            };\n          },\n\n          _ZN3art12StackVisitorC2EPNS_6ThreadEPNS_7ContextENS0_13StackWalkKindEjb: ['art::StackVisitor::StackVisitor', 'void', ['pointer', 'pointer', 'pointer', 'uint', 'uint', 'bool']],\n          _ZN3art12StackVisitorC2EPNS_6ThreadEPNS_7ContextENS0_13StackWalkKindEmb: ['art::StackVisitor::StackVisitor', 'void', ['pointer', 'pointer', 'pointer', 'uint', 'size_t', 'bool']],\n          _ZN3art12StackVisitor9WalkStackILNS0_16CountTransitionsE0EEEvb: ['art::StackVisitor::WalkStack', 'void', ['pointer', 'bool']],\n          _ZNK3art12StackVisitor9GetMethodEv: ['art::StackVisitor::GetMethod', 'pointer', ['pointer']],\n          _ZNK3art12StackVisitor16DescribeLocationEv: function (address) {\n            this['art::StackVisitor::DescribeLocation'] = makeCxxMethodWrapperReturningStdStringByValue(address, ['pointer']);\n          },\n          _ZNK3art12StackVisitor24GetCurrentQuickFrameInfoEv: function (address) {\n            this['art::StackVisitor::GetCurrentQuickFrameInfo'] = makeArtQuickFrameInfoGetter(address);\n          },\n\n          _ZN3art6Thread18GetLongJumpContextEv: ['art::Thread::GetLongJumpContext', 'pointer', ['pointer']],\n\n          _ZN3art6mirror5Class13GetDescriptorEPNSt3__112basic_stringIcNS2_11char_traitsIcEENS2_9allocatorIcEEEE: function (address) {\n            this['art::mirror::Class::GetDescriptor'] = address;\n          },\n          _ZN3art6mirror5Class11GetLocationEv: function (address) {\n            this['art::mirror::Class::GetLocation'] = makeCxxMethodWrapperReturningStdStringByValue(address, ['pointer']);\n          },\n\n          _ZN3art9ArtMethod12PrettyMethodEb: function (address) {\n            this['art::ArtMethod::PrettyMethod'] = makeCxxMethodWrapperReturningStdStringByValue(address, ['pointer', 'bool']);\n          },\n          _ZN3art12PrettyMethodEPNS_9ArtMethodEb: function (address) {\n            this['art::ArtMethod::PrettyMethodNullSafe'] = makeCxxMethodWrapperReturningStdStringByValue(address, ['pointer', 'bool']);\n          },\n\n          // Android < 6 for cloneArtMethod()\n          _ZN3art6Thread14CurrentFromGdbEv: ['art::Thread::CurrentFromGdb', 'pointer', []],\n          _ZN3art6mirror6Object5CloneEPNS_6ThreadE: function (address) {\n            this['art::mirror::Object::Clone'] = new NativeFunction(address, 'pointer', ['pointer', 'pointer'], nativeFunctionOptions);\n          },\n          _ZN3art6mirror6Object5CloneEPNS_6ThreadEm: function (address) {\n            const clone = new NativeFunction(address, 'pointer', ['pointer', 'pointer', 'pointer'], nativeFunctionOptions);\n            this['art::mirror::Object::Clone'] = function (thisPtr, threadPtr) {\n              const numTargetBytes = NULL;\n              return clone(thisPtr, threadPtr, numTargetBytes);\n            };\n          },\n          _ZN3art6mirror6Object5CloneEPNS_6ThreadEj: function (address) {\n            const clone = new NativeFunction(address, 'pointer', ['pointer', 'pointer', 'uint'], nativeFunctionOptions);\n            this['art::mirror::Object::Clone'] = function (thisPtr, threadPtr) {\n              const numTargetBytes = 0;\n              return clone(thisPtr, threadPtr, numTargetBytes);\n            };\n          },\n\n          _ZN3art3Dbg14SetJdwpAllowedEb: ['art::Dbg::SetJdwpAllowed', 'void', ['bool']],\n          _ZN3art3Dbg13ConfigureJdwpERKNS_4JDWP11JdwpOptionsE: ['art::Dbg::ConfigureJdwp', 'void', ['pointer']],\n          _ZN3art31InternalDebuggerControlCallback13StartDebuggerEv: ['art::InternalDebuggerControlCallback::StartDebugger', 'void', ['pointer']],\n          _ZN3art3Dbg9StartJdwpEv: ['art::Dbg::StartJdwp', 'void', []],\n          _ZN3art3Dbg8GoActiveEv: ['art::Dbg::GoActive', 'void', []],\n          _ZN3art3Dbg21RequestDeoptimizationERKNS_21DeoptimizationRequestE: ['art::Dbg::RequestDeoptimization', 'void', ['pointer']],\n          _ZN3art3Dbg20ManageDeoptimizationEv: ['art::Dbg::ManageDeoptimization', 'void', []],\n\n          _ZN3art15instrumentation15Instrumentation20EnableDeoptimizationEv: ['art::Instrumentation::EnableDeoptimization', 'void', ['pointer']],\n          // Android >= 6\n          _ZN3art15instrumentation15Instrumentation20DeoptimizeEverythingEPKc: ['art::Instrumentation::DeoptimizeEverything', 'void', ['pointer', 'pointer']],\n          // Android < 6\n          _ZN3art15instrumentation15Instrumentation20DeoptimizeEverythingEv: function (address) {\n            const deoptimize = new NativeFunction(address, 'void', ['pointer'], nativeFunctionOptions);\n            this['art::Instrumentation::DeoptimizeEverything'] = function (instrumentation, key) {\n              deoptimize(instrumentation);\n            };\n          },\n          _ZN3art7Runtime19DeoptimizeBootImageEv: ['art::Runtime::DeoptimizeBootImage', 'void', ['pointer']],\n          _ZN3art15instrumentation15Instrumentation10DeoptimizeEPNS_9ArtMethodE: ['art::Instrumentation::Deoptimize', 'void', ['pointer', 'pointer']],\n\n          // Android >= 11\n          _ZN3art3jni12JniIdManager14DecodeMethodIdEP10_jmethodID: ['art::jni::JniIdManager::DecodeMethodId', 'pointer', ['pointer', 'pointer']],\n          _ZN3art11interpreter18GetNterpEntryPointEv: ['art::interpreter::GetNterpEntryPoint', 'pointer', []],\n\n          _ZN3art7Monitor17TranslateLocationEPNS_9ArtMethodEjPPKcPi: ['art::Monitor::TranslateLocation', 'void', ['pointer', 'uint32', 'pointer', 'pointer']]\n        },\n        variables: {\n          _ZN3art3Dbg9gRegistryE: function (address) {\n            this.isJdwpStarted = () => !address.readPointer().isNull();\n          },\n          _ZN3art3Dbg15gDebuggerActiveE: function (address) {\n            this.isDebuggerActive = () => !!address.readU8();\n          }\n        },\n        optionals: [\n          'artInterpreterToCompiledCodeBridge',\n          '_ZN3art9JavaVMExt12AddGlobalRefEPNS_6ThreadENS_6ObjPtrINS_6mirror6ObjectEEE',\n          '_ZN3art9JavaVMExt12AddGlobalRefEPNS_6ThreadEPNS_6mirror6ObjectE',\n          '_ZN3art9JavaVMExt12DecodeGlobalEPv',\n          '_ZN3art9JavaVMExt12DecodeGlobalEPNS_6ThreadEPv',\n          '_ZNK3art6Thread19DecodeGlobalJObjectEP8_jobject',\n          '_ZNK3art6Thread13DecodeJObjectEP8_jobject',\n          '_ZN3art10ThreadList10SuspendAllEPKcb',\n          '_ZN3art10ThreadList10SuspendAllEv',\n          '_ZN3art11ClassLinker12VisitClassesEPNS_12ClassVisitorE',\n          '_ZN3art11ClassLinker12VisitClassesEPFbPNS_6mirror5ClassEPvES4_',\n          '_ZNK3art11ClassLinker17VisitClassLoadersEPNS_18ClassLoaderVisitorE',\n          '_ZN3art6mirror6Object5CloneEPNS_6ThreadE',\n          '_ZN3art6mirror6Object5CloneEPNS_6ThreadEm',\n          '_ZN3art6mirror6Object5CloneEPNS_6ThreadEj',\n          '_ZN3art22IndirectReferenceTable3AddEjPNS_6mirror6ObjectE',\n          '_ZN3art22IndirectReferenceTable3AddENS_15IRTSegmentStateENS_6ObjPtrINS_6mirror6ObjectEEE',\n          '_ZN3art2gc4Heap12VisitObjectsEPFvPNS_6mirror6ObjectEPvES5_',\n          '_ZN3art2gc4Heap12GetInstancesERNS_24VariableSizedHandleScopeENS_6HandleINS_6mirror5ClassEEEiRNSt3__16vectorINS4_INS5_6ObjectEEENS8_9allocatorISB_EEEE',\n          '_ZN3art2gc4Heap12GetInstancesERNS_24VariableSizedHandleScopeENS_6HandleINS_6mirror5ClassEEEbiRNSt3__16vectorINS4_INS5_6ObjectEEENS8_9allocatorISB_EEEE',\n          '_ZN3art12StackVisitorC2EPNS_6ThreadEPNS_7ContextENS0_13StackWalkKindEjb',\n          '_ZN3art12StackVisitorC2EPNS_6ThreadEPNS_7ContextENS0_13StackWalkKindEmb',\n          '_ZN3art12StackVisitor9WalkStackILNS0_16CountTransitionsE0EEEvb',\n          '_ZNK3art12StackVisitor9GetMethodEv',\n          '_ZNK3art12StackVisitor16DescribeLocationEv',\n          '_ZNK3art12StackVisitor24GetCurrentQuickFrameInfoEv',\n          '_ZN3art6Thread18GetLongJumpContextEv',\n          '_ZN3art6mirror5Class13GetDescriptorEPNSt3__112basic_stringIcNS2_11char_traitsIcEENS2_9allocatorIcEEEE',\n          '_ZN3art6mirror5Class11GetLocationEv',\n          '_ZN3art9ArtMethod12PrettyMethodEb',\n          '_ZN3art12PrettyMethodEPNS_9ArtMethodEb',\n          '_ZN3art3Dbg13ConfigureJdwpERKNS_4JDWP11JdwpOptionsE',\n          '_ZN3art31InternalDebuggerControlCallback13StartDebuggerEv',\n          '_ZN3art3Dbg15gDebuggerActiveE',\n          '_ZN3art15instrumentation15Instrumentation20EnableDeoptimizationEv',\n          '_ZN3art15instrumentation15Instrumentation20DeoptimizeEverythingEPKc',\n          '_ZN3art15instrumentation15Instrumentation20DeoptimizeEverythingEv',\n          '_ZN3art7Runtime19DeoptimizeBootImageEv',\n          '_ZN3art15instrumentation15Instrumentation10DeoptimizeEPNS_9ArtMethodE',\n          '_ZN3art3Dbg9StartJdwpEv',\n          '_ZN3art3Dbg8GoActiveEv',\n          '_ZN3art3Dbg21RequestDeoptimizationERKNS_21DeoptimizationRequestE',\n          '_ZN3art3Dbg20ManageDeoptimizationEv',\n          '_ZN3art3Dbg9gRegistryE',\n          '_ZN3art3jni12JniIdManager14DecodeMethodIdEP10_jmethodID',\n          '_ZN3art11interpreter18GetNterpEntryPointEv',\n          '_ZN3art7Monitor17TranslateLocationEPNS_9ArtMethodEjPPKcPi'\n        ]\n      }]\n    : [{\n        module: vmModule.path,\n        functions: {\n          _Z20dvmDecodeIndirectRefP6ThreadP8_jobject: ['dvmDecodeIndirectRef', 'pointer', ['pointer', 'pointer']],\n          _Z15dvmUseJNIBridgeP6MethodPv: ['dvmUseJNIBridge', 'void', ['pointer', 'pointer']],\n          _Z20dvmHeapSourceGetBasev: ['dvmHeapSourceGetBase', 'pointer', []],\n          _Z21dvmHeapSourceGetLimitv: ['dvmHeapSourceGetLimit', 'pointer', []],\n          _Z16dvmIsValidObjectPK6Object: ['dvmIsValidObject', 'uint8', ['pointer']],\n          JNI_GetCreatedJavaVMs: ['JNI_GetCreatedJavaVMs', 'int', ['pointer', 'int', 'pointer']]\n        },\n        variables: {\n          gDvmJni: function (address) {\n            this.gDvmJni = address;\n          },\n          gDvm: function (address) {\n            this.gDvm = address;\n          }\n        }\n      }];\n\n  const missing = [];\n\n  pending.forEach(function (api) {\n    const functions = api.functions || {};\n    const variables = api.variables || {};\n    const optionals = new Set(api.optionals || []);\n\n    const exportByName = Module\n      .enumerateExports(api.module)\n      .reduce(function (result, exp) {\n        result[exp.name] = exp;\n        return result;\n      }, {});\n\n    Object.keys(functions)\n      .forEach(function (name) {\n        const exp = exportByName[name];\n        if (exp !== undefined && exp.type === 'function') {\n          const signature = functions[name];\n          if (typeof signature === 'function') {\n            signature.call(temporaryApi, exp.address);\n          } else {\n            temporaryApi[signature[0]] = new NativeFunction(exp.address, signature[1], signature[2], nativeFunctionOptions);\n          }\n        } else {\n          if (!optionals.has(name)) {\n            missing.push(name);\n          }\n        }\n      });\n\n    Object.keys(variables)\n      .forEach(function (name) {\n        const exp = exportByName[name];\n        if (exp !== undefined && exp.type === 'variable') {\n          const handler = variables[name];\n          handler.call(temporaryApi, exp.address);\n        } else {\n          if (!optionals.has(name)) {\n            missing.push(name);\n          }\n        }\n      });\n  });\n\n  if (missing.length > 0) {\n    throw new Error('Java API only partially available; please file a bug. Missing: ' + missing.join(', '));\n  }\n\n  const vms = Memory.alloc(pointerSize);\n  const vmCount = Memory.alloc(jsizeSize);\n  checkJniResult('JNI_GetCreatedJavaVMs', temporaryApi.JNI_GetCreatedJavaVMs(vms, 1, vmCount));\n  if (vmCount.readInt() === 0) {\n    return null;\n  }\n  temporaryApi.vm = vms.readPointer();\n\n  if (isArt) {\n    const apiLevel = getAndroidApiLevel();\n\n    let kAccCompileDontBother;\n    if (apiLevel >= 27) {\n      kAccCompileDontBother = 0x02000000;\n    } else if (apiLevel >= 24) {\n      kAccCompileDontBother = 0x01000000;\n    } else {\n      kAccCompileDontBother = 0;\n    }\n    temporaryApi.kAccCompileDontBother = kAccCompileDontBother;\n\n    const artRuntime = temporaryApi.vm.add(pointerSize).readPointer();\n    temporaryApi.artRuntime = artRuntime;\n    const runtimeSpec = getArtRuntimeSpec(temporaryApi);\n    const runtimeOffset = runtimeSpec.offset;\n    const instrumentationOffset = runtimeOffset.instrumentation;\n    temporaryApi.artInstrumentation = (instrumentationOffset !== null) ? artRuntime.add(instrumentationOffset) : null;\n\n    temporaryApi.artHeap = artRuntime.add(runtimeOffset.heap).readPointer();\n    temporaryApi.artThreadList = artRuntime.add(runtimeOffset.threadList).readPointer();\n\n    /*\n     * We must use the *correct* copy (or address) of art_quick_generic_jni_trampoline\n     * in order for the stack trace to recognize the JNI stub quick frame.\n     *\n     * For ARTs for Android 6.x we can just use the JNI trampoline built into ART.\n     */\n    const classLinker = artRuntime.add(runtimeOffset.classLinker).readPointer();\n\n    const classLinkerOffsets = getArtClassLinkerSpec(artRuntime, runtimeSpec).offset;\n    const quickResolutionTrampoline = classLinker.add(classLinkerOffsets.quickResolutionTrampoline).readPointer();\n    const quickImtConflictTrampoline = classLinker.add(classLinkerOffsets.quickImtConflictTrampoline).readPointer();\n    const quickGenericJniTrampoline = classLinker.add(classLinkerOffsets.quickGenericJniTrampoline).readPointer();\n    const quickToInterpreterBridgeTrampoline = classLinker.add(classLinkerOffsets.quickToInterpreterBridgeTrampoline).readPointer();\n\n    temporaryApi.artClassLinker = {\n      address: classLinker,\n      quickResolutionTrampoline,\n      quickImtConflictTrampoline,\n      quickGenericJniTrampoline,\n      quickToInterpreterBridgeTrampoline\n    };\n\n    const vm = new VM(temporaryApi);\n\n    temporaryApi.artQuickGenericJniTrampoline = getArtQuickEntrypointFromTrampoline(quickGenericJniTrampoline, vm);\n    temporaryApi.artQuickToInterpreterBridge = getArtQuickEntrypointFromTrampoline(quickToInterpreterBridgeTrampoline, vm);\n    temporaryApi.artQuickResolutionTrampoline = getArtQuickEntrypointFromTrampoline(quickResolutionTrampoline, vm);\n\n    if (temporaryApi['art::JavaVMExt::AddGlobalRef'] === undefined) {\n      temporaryApi['art::JavaVMExt::AddGlobalRef'] = makeAddGlobalRefFallbackForAndroid5(temporaryApi);\n    }\n    if (temporaryApi['art::JavaVMExt::DecodeGlobal'] === undefined) {\n      temporaryApi['art::JavaVMExt::DecodeGlobal'] = makeDecodeGlobalFallback(temporaryApi);\n    }\n    if (temporaryApi['art::ArtMethod::PrettyMethod'] === undefined) {\n      temporaryApi['art::ArtMethod::PrettyMethod'] = temporaryApi['art::ArtMethod::PrettyMethodNullSafe'];\n    }\n    if (temporaryApi['art::interpreter::GetNterpEntryPoint'] !== undefined) {\n      temporaryApi.artNterpEntryPoint = temporaryApi['art::interpreter::GetNterpEntryPoint']();\n    }\n\n    artController = makeArtController(vm);\n\n    fixupArtQuickDeliverExceptionBug(temporaryApi);\n\n    let cachedJvmti = null;\n    Object.defineProperty(temporaryApi, 'jvmti', {\n      get () {\n        if (cachedJvmti === null) {\n          cachedJvmti = [tryGetEnvJvmti(vm, this.artRuntime)];\n        }\n        return cachedJvmti[0];\n      }\n    });\n  }\n\n  const cxxImports = Module.enumerateImports(vmModule.path)\n    .filter(imp => imp.name.indexOf('_Z') === 0)\n    .reduce((result, imp) => {\n      result[imp.name] = imp.address;\n      return result;\n    }, {});\n  temporaryApi.$new = new NativeFunction(cxxImports._Znwm || cxxImports._Znwj, 'pointer', ['ulong'], nativeFunctionOptions);\n  temporaryApi.$delete = new NativeFunction(cxxImports._ZdlPv, 'void', ['pointer'], nativeFunctionOptions);\n\n  MethodMangler = isArt ? ArtMethodMangler : DalvikMethodMangler;\n\n  return temporaryApi;\n}\n\nfunction tryGetEnvJvmti (vm, runtime) {\n  let env = null;\n\n  vm.perform(() => {\n    const ensurePluginLoaded = new NativeFunction(\n      Module.getExportByName('libart.so', '_ZN3art7Runtime18EnsurePluginLoadedEPKcPNSt3__112basic_stringIcNS3_11char_traitsIcEENS3_9allocatorIcEEEE'),\n      'bool',\n      ['pointer', 'pointer', 'pointer']);\n    const errorPtr = Memory.alloc(pointerSize);\n    const success = ensurePluginLoaded(runtime, Memory.allocUtf8String('libopenjdkjvmti.so'), errorPtr);\n    if (!success) {\n      // FIXME: Avoid leaking error\n      return;\n    }\n\n    const kArtTiVersion = jvmtiVersion.v1_2 | 0x40000000;\n    const handle = vm.tryGetEnvHandle(kArtTiVersion);\n    if (handle === null) {\n      return;\n    }\n    env = new EnvJvmti(handle, vm);\n\n    const capaBuf = Memory.alloc(8);\n    capaBuf.writeU64(jvmtiCapabilities.canTagObjects);\n    const result = env.addCapabilities(capaBuf);\n    if (result !== JNI_OK) {\n      env = null;\n    }\n  });\n\n  return env;\n}\n\nfunction ensureClassInitialized (env, classRef) {\n  const api = getApi();\n  if (api.flavor !== 'art') {\n    return;\n  }\n\n  env.getFieldId(classRef, 'x', 'Z');\n  env.exceptionClear();\n}\n\nfunction getArtVMSpec (api) {\n  return {\n    offset: (pointerSize === 4)\n      ? {\n          globalsLock: 32,\n          globals: 72\n        }\n      : {\n          globalsLock: 64,\n          globals: 112\n        }\n  };\n}\n\nfunction _getArtRuntimeSpec (api) {\n  /*\n   * class Runtime {\n   * ...\n   * gc::Heap* heap_;                <-- we need to find this\n   * std::unique_ptr<ArenaPool> jit_arena_pool_;     <----- API level >= 24\n   * std::unique_ptr<ArenaPool> arena_pool_;             __\n   * std::unique_ptr<ArenaPool> low_4gb_arena_pool_/linear_alloc_arena_pool_; <--|__ API level >= 23\n   * std::unique_ptr<LinearAlloc> linear_alloc_;         \_\n   * std::atomic<LinearAlloc*> startup_linear_alloc_;<----- API level >= 34\n   * size_t max_spins_before_thin_lock_inflation_;\n   * MonitorList* monitor_list_;\n   * MonitorPool* monitor_pool_;\n   * ThreadList* thread_list_;        <--- and these\n   * InternTable* intern_table_;      <--/\n   * ClassLinker* class_linker_;      <-/\n   * SignalCatcher* signal_catcher_;\n   * SmallIrtAllocator* small_irt_allocator_; <------------ API level >= 33 or Android Tiramisu Developer Preview\n   * std::unique_ptr<jni::JniIdManager> jni_id_manager_; <- API level >= 30 or Android R Developer Preview\n   * bool use_tombstoned_traces_;     <-------------------- API level 27/28\n   * std::string stack_trace_file_;   <-------------------- API level <= 28\n   * JavaVMExt* java_vm_;             <-- so we find this then calculate our way backwards\n   * ...\n   * }\n   */\n\n  const vm = api.vm;\n  const runtime = api.artRuntime;\n\n  const startOffset = (pointerSize === 4) ? 200 : 384;\n  const endOffset = startOffset + (100 * pointerSize);\n\n  const apiLevel = getAndroidApiLevel();\n  const codename = getAndroidCodename();\n  const isApiLevel34OrApexEquivalent = Module.findExportByName('libart.so', '_ZN3art7AppInfo29GetPrimaryApkReferenceProfileEv') !== null;\n\n  let spec = null;\n\n  for (let offset = startOffset; offset !== endOffset; offset += pointerSize) {\n    const value = runtime.add(offset).readPointer();\n    if (value.equals(vm)) {\n      let classLinkerOffsets;\n      let jniIdManagerOffset = null;\n      if (apiLevel >= 33 || codename === 'Tiramisu') {\n        classLinkerOffsets = [offset - (4 * pointerSize)];\n        jniIdManagerOffset = offset - pointerSize;\n      } else if (apiLevel >= 30 || codename === 'R') {\n        classLinkerOffsets = [offset - (3 * pointerSize), offset - (4 * pointerSize)];\n        jniIdManagerOffset = offset - pointerSize;\n      } else if (apiLevel >= 29) {\n        classLinkerOffsets = [offset - (2 * pointerSize)];\n      } else if (apiLevel >= 27) {\n        classLinkerOffsets = [offset - STD_STRING_SIZE - (3 * pointerSize)];\n      } else {\n        classLinkerOffsets = [offset - STD_STRING_SIZE - (2 * pointerSize)];\n      }\n\n      for (const classLinkerOffset of classLinkerOffsets) {\n        const internTableOffset = classLinkerOffset - pointerSize;\n        const threadListOffset = internTableOffset - pointerSize;\n\n        let heapOffset;\n        if (isApiLevel34OrApexEquivalent) {\n          heapOffset = threadListOffset - (9 * pointerSize);\n        } else if (apiLevel >= 24) {\n          heapOffset = threadListOffset - (8 * pointerSize);\n        } else if (apiLevel >= 23) {\n          heapOffset = threadListOffset - (7 * pointerSize);\n        } else {\n          heapOffset = threadListOffset - (4 * pointerSize);\n        }\n\n        const candidate = {\n          offset: {\n            heap: heapOffset,\n            threadList: threadListOffset,\n            internTable: internTableOffset,\n            classLinker: classLinkerOffset,\n            jniIdManager: jniIdManagerOffset\n          }\n        };\n        if (tryGetArtClassLinkerSpec(runtime, candidate) !== null) {\n          spec = candidate;\n          break;\n        }\n      }\n\n      break;\n    }\n  }\n\n  if (spec === null) {\n    throw new Error('Unable to determine Runtime field offsets');\n  }\n\n  spec.offset.instrumentation = tryDetectInstrumentationOffset(api);\n  spec.offset.jniIdsIndirection = tryDetectJniIdsIndirectionOffset();\n\n  return spec;\n}\n\nconst instrumentationOffsetParsers = {\n  ia32: parsex86InstrumentationOffset,\n  x64: parsex86InstrumentationOffset,\n  arm: parseArmInstrumentationOffset,\n  arm64: parseArm64InstrumentationOffset\n};\n\nfunction tryDetectInstrumentationOffset (api) {\n  const impl = api['art::Runtime::DeoptimizeBootImage'];\n  if (impl === undefined) {\n    return null;\n  }\n\n  return parseInstructionsAt(impl, instrumentationOffsetParsers[Process.arch], { limit: 30 });\n}\n\nfunction parsex86InstrumentationOffset (insn) {\n  if (insn.mnemonic !== 'lea') {\n    return null;\n  }\n\n  const offset = insn.operands[1].value.disp;\n  if (offset < 0x100 || offset > 0x400) {\n    return null;\n  }\n\n  return offset;\n}\n\nfunction parseArmInstrumentationOffset (insn) {\n  if (insn.mnemonic !== 'add.w') {\n    return null;\n  }\n\n  const ops = insn.operands;\n  if (ops.length !== 3) {\n    return null;\n  }\n\n  const op2 = ops[2];\n  if (op2.type !== 'imm') {\n    return null;\n  }\n\n  return op2.value;\n}\n\nfunction parseArm64InstrumentationOffset (insn) {\n  if (insn.mnemonic !== 'add') {\n    return null;\n  }\n\n  const ops = insn.operands;\n  if (ops.length !== 3) {\n    return null;\n  }\n\n  if (ops[0].value === 'sp' || ops[1].value === 'sp') {\n    return null;\n  }\n\n  const op2 = ops[2];\n  if (op2.type !== 'imm') {\n    return null;\n  }\n\n  const offset = op2.value.valueOf();\n  if (offset < 0x100 || offset > 0x400) {\n    return null;\n  }\n\n  return offset;\n}\n\nconst jniIdsIndirectionOffsetParsers = {\n  ia32: parsex86JniIdsIndirectionOffset,\n  x64: parsex86JniIdsIndirectionOffset,\n  arm: parseArmJniIdsIndirectionOffset,\n  arm64: parseArm64JniIdsIndirectionOffset\n};\n\nfunction tryDetectJniIdsIndirectionOffset () {\n  const impl = Module.findExportByName('libart.so', '_ZN3art7Runtime12SetJniIdTypeENS_9JniIdTypeE');\n  if (impl === null) {\n    return null;\n  }\n\n  const offset = parseInstructionsAt(impl, jniIdsIndirectionOffsetParsers[Process.arch], { limit: 20 });\n  if (offset === null) {\n    throw new Error('Unable to determine Runtime.jni_ids_indirection_ offset');\n  }\n\n  return offset;\n}\n\nfunction parsex86JniIdsIndirectionOffset (insn) {\n  if (insn.mnemonic === 'cmp') {\n    return insn.operands[0].value.disp;\n  }\n\n  return null;\n}\n\nfunction parseArmJniIdsIndirectionOffset (insn) {\n  if (insn.mnemonic === 'ldr.w') {\n    return insn.operands[1].value.disp;\n  }\n\n  return null;\n}\n\nfunction parseArm64JniIdsIndirectionOffset (insn, prevInsn) {\n  if (prevInsn === null) {\n    return null;\n  }\n\n  const { mnemonic } = insn;\n  const { mnemonic: prevMnemonic } = prevInsn;\n\n  if ((mnemonic === 'cmp' && prevMnemonic === 'ldr') || (mnemonic === 'bl' && prevMnemonic === 'str')) {\n    return prevInsn.operands[1].value.disp;\n  }\n\n  return null;\n}\n\nfunction _getArtInstrumentationSpec () {\n  const deoptimizationEnabledOffsets = {\n    '4-21': 136,\n    '4-22': 136,\n    '4-23': 172,\n    '4-24': 196,\n    '4-25': 196,\n    '4-26': 196,\n    '4-27': 196,\n    '4-28': 212,\n    '4-29': 172,\n    '4-30': 180,\n    '8-21': 224,\n    '8-22': 224,\n    '8-23': 296,\n    '8-24': 344,\n    '8-25': 344,\n    '8-26': 352,\n    '8-27': 352,\n    '8-28': 392,\n    '8-29': 328,\n    '8-30': 336\n  };\n\n  const deoptEnabledOffset = deoptimizationEnabledOffsets[`${pointerSize}-${getAndroidApiLevel()}`];\n  if (deoptEnabledOffset === undefined) {\n    throw new Error('Unable to determine Instrumentation field offsets');\n  }\n\n  return {\n    offset: {\n      forcedInterpretOnly: 4,\n      deoptimizationEnabled: deoptEnabledOffset\n    }\n  };\n}\n\nfunction getArtClassLinkerSpec (runtime, runtimeSpec) {\n  const spec = tryGetArtClassLinkerSpec(runtime, runtimeSpec);\n  if (spec === null) {\n    throw new Error('Unable to determine ClassLinker field offsets');\n  }\n  return spec;\n}\n\nfunction tryGetArtClassLinkerSpec (runtime, runtimeSpec) {\n  if (cachedArtClassLinkerSpec !== null) {\n    return cachedArtClassLinkerSpec;\n  }\n\n  /*\n   * On Android 5.x:\n   *\n   * class ClassLinker {\n   * ...\n   * InternTable* intern_table_;                          <-- We find this then calculate our way forwards\n   * const void* portable_resolution_trampoline_;\n   * const void* quick_resolution_trampoline_;\n   * const void* portable_imt_conflict_trampoline_;\n   * const void* quick_imt_conflict_trampoline_;\n   * const void* quick_generic_jni_trampoline_;           <-- ...to this\n   * const void* quick_to_interpreter_bridge_trampoline_;\n   * ...\n   * }\n   *\n   * On Android 6.x and above:\n   *\n   * class ClassLinker {\n   * ...\n   * InternTable* intern_table_;                          <-- We find this then calculate our way forwards\n   * const void* quick_resolution_trampoline_;\n   * const void* quick_imt_conflict_trampoline_;\n   * const void* quick_generic_jni_trampoline_;           <-- ...to this\n   * const void* quick_to_interpreter_bridge_trampoline_;\n   * ...\n   * }\n   */\n\n  const { classLinker: classLinkerOffset, internTable: internTableOffset } = runtimeSpec.offset;\n  const classLinker = runtime.add(classLinkerOffset).readPointer();\n  const internTable = runtime.add(internTableOffset).readPointer();\n\n  const startOffset = (pointerSize === 4) ? 100 : 200;\n  const endOffset = startOffset + (100 * pointerSize);\n\n  const apiLevel = getAndroidApiLevel();\n\n  let spec = null;\n\n  for (let offset = startOffset; offset !== endOffset; offset += pointerSize) {\n    const value = classLinker.add(offset).readPointer();\n    if (value.equals(internTable)) {\n      let delta;\n      if (apiLevel >= 30 || getAndroidCodename() === 'R') {\n        delta = 6;\n      } else if (apiLevel >= 29) {\n        delta = 4;\n      } else if (apiLevel >= 23) {\n        delta = 3;\n      } else {\n        delta = 5;\n      }\n\n      const quickGenericJniTrampolineOffset = offset + (delta * pointerSize);\n\n      let quickResolutionTrampolineOffset;\n      if (apiLevel >= 23) {\n        quickResolutionTrampolineOffset = quickGenericJniTrampolineOffset - (2 * pointerSize);\n      } else {\n        quickResolutionTrampolineOffset = quickGenericJniTrampolineOffset - (3 * pointerSize);\n      }\n\n      spec = {\n        offset: {\n          quickResolutionTrampoline: quickResolutionTrampolineOffset,\n          quickImtConflictTrampoline: quickGenericJniTrampolineOffset - pointerSize,\n          quickGenericJniTrampoline: quickGenericJniTrampolineOffset,\n          quickToInterpreterBridgeTrampoline: quickGenericJniTrampolineOffset + pointerSize\n        }\n      };\n\n      break;\n    }\n  }\n\n  if (spec !== null) {\n    cachedArtClassLinkerSpec = spec;\n  }\n\n  return spec;\n}\n\nfunction getArtClassSpec (vm) {\n  let apiLevel;\n  try {\n    apiLevel = getAndroidApiLevel();\n  } catch (e) {\n    return null;\n  }\n\n  if (apiLevel < 24) {\n    return null;\n  }\n\n  let base, cmo;\n  if (apiLevel >= 26) {\n    base = 40;\n    cmo = 116;\n  } else {\n    base = 56;\n    cmo = 124;\n  }\n\n  return {\n    offset: {\n      ifields: base,\n      methods: base + 8,\n      sfields: base + 16,\n      copiedMethodsOffset: cmo\n    }\n  };\n}\n\nfunction _getArtMethodSpec (vm) {\n  const api = getApi();\n  let spec;\n\n  vm.perform(env => {\n    const process = env.findClass('android/os/Process');\n    const getElapsedCpuTime = unwrapMethodId(env.getStaticMethodId(process, 'getElapsedCpuTime', '()J'));\n    env.deleteLocalRef(process);\n\n    const runtimeModule = Process.getModuleByName('libandroid_runtime.so');\n    const runtimeStart = runtimeModule.base;\n    const runtimeEnd = runtimeStart.add(runtimeModule.size);\n\n    const apiLevel = getAndroidApiLevel();\n\n    const entrypointFieldSize = (apiLevel <= 21) ? 8 : pointerSize;\n\n    const expectedAccessFlags = kAccPublic | kAccStatic | kAccFinal | kAccNative;\n    const relevantAccessFlagsMask = ~(kAccFastInterpreterToInterpreterInvoke | kAccPublicApi | kAccNterpInvokeFastPathFlag) >>> 0;\n\n    let jniCodeOffset = null;\n    let accessFlagsOffset = null;\n    let remaining = 2;\n    for (let offset = 0; offset !== 64 && remaining !== 0; offset += 4) {\n      const field = getElapsedCpuTime.add(offset);\n\n      if (jniCodeOffset === null) {\n        const address = field.readPointer();\n        if (address.compare(runtimeStart) >= 0 && address.compare(runtimeEnd) < 0) {\n          jniCodeOffset = offset;\n          remaining--;\n        }\n      }\n\n      if (accessFlagsOffset === null) {\n        const flags = field.readU32();\n        if ((flags & relevantAccessFlagsMask) === expectedAccessFlags) {\n          accessFlagsOffset = offset;\n          remaining--;\n        }\n      }\n    }\n\n    if (remaining !== 0) {\n      throw new Error('Unable to determine ArtMethod field offsets');\n    }\n\n    const quickCodeOffset = jniCodeOffset + entrypointFieldSize;\n\n    const size = (apiLevel <= 21) ? (quickCodeOffset + 32) : (quickCodeOffset + pointerSize);\n\n    spec = {\n      size,\n      offset: {\n        jniCode: jniCodeOffset,\n        quickCode: quickCodeOffset,\n        accessFlags: accessFlagsOffset\n      }\n    };\n\n    if ('artInterpreterToCompiledCodeBridge' in api) {\n      spec.offset.interpreterCode = jniCodeOffset - entrypointFieldSize;\n    }\n  });\n\n  return spec;\n}\n\nfunction getArtFieldSpec (vm) {\n  const apiLevel = getAndroidApiLevel();\n\n  if (apiLevel >= 23) {\n    return {\n      size: 16,\n      offset: {\n        accessFlags: 4\n      }\n    };\n  }\n\n  if (apiLevel >= 21) {\n    return {\n      size: 24,\n      offset: {\n        accessFlags: 12\n      }\n    };\n  }\n\n  return null;\n}\n\nfunction _getArtThreadSpec (vm) {\n  /*\n   * bool32_t is_exception_reported_to_instrumentation_; <-- We need this on API level <= 22\n   * ...\n   * mirror::Throwable* exception;                       <-- ...and this on all versions\n   * uint8_t* stack_end;\n   * ManagedStack managed_stack;\n   * uintptr_t* suspend_trigger;\n   * JNIEnvExt* jni_env;                                 <-- We find this then calculate our way backwards/forwards\n   * JNIEnvExt* tmp_jni_env;                             <-- API level >= 23\n   * Thread* self;\n   * mirror::Object* opeer;\n   * jobject jpeer;\n   * uint8_t* stack_begin;\n   * size_t stack_size;\n   * ThrowLocation throw_location;                       <-- ...and this on API level <= 22\n   * union DepsOrStackTraceSample {\n   *   DepsOrStackTraceSample() {\n   *     verifier_deps = nullptr;\n   *     stack_trace_sample = nullptr;\n   *   }\n   *   std::vector<ArtMethod*>* stack_trace_sample;\n   *   verifier::VerifierDeps* verifier_deps;\n   * } deps_or_stack_trace_sample;\n   * Thread* wait_next;\n   * mirror::Object* monitor_enter_object;\n   * BaseHandleScope* top_handle_scope;                  <-- ...and to this on all versions\n   */\n\n  const apiLevel = getAndroidApiLevel();\n\n  let spec;\n\n  vm.perform(env => {\n    const threadHandle = getArtThreadFromEnv(env);\n    const envHandle = env.handle;\n\n    let isExceptionReportedOffset = null;\n    let exceptionOffset = null;\n    let throwLocationOffset = null;\n    let topHandleScopeOffset = null;\n    let managedStackOffset = null;\n    let selfOffset = null;\n\n    for (let offset = 144; offset !== 256; offset += pointerSize) {\n      const field = threadHandle.add(offset);\n\n      const value = field.readPointer();\n      if (value.equals(envHandle)) {\n        exceptionOffset = offset - (6 * pointerSize);\n        managedStackOffset = offset - (4 * pointerSize);\n        selfOffset = offset + (2 * pointerSize);\n        if (apiLevel <= 22) {\n          exceptionOffset -= pointerSize;\n\n          isExceptionReportedOffset = exceptionOffset - pointerSize - (9 * 8) - (3 * 4);\n\n          throwLocationOffset = offset + (6 * pointerSize);\n\n          managedStackOffset -= pointerSize;\n\n          selfOffset -= pointerSize;\n        }\n\n        topHandleScopeOffset = offset + (9 * pointerSize);\n        if (apiLevel <= 22) {\n          topHandleScopeOffset += (2 * pointerSize) + 4;\n          if (pointerSize === 8) {\n            topHandleScopeOffset += 4;\n          }\n        }\n        if (apiLevel >= 23) {\n          topHandleScopeOffset += pointerSize;\n        }\n\n        break;\n      }\n    }\n\n    if (topHandleScopeOffset === null) {\n      throw new Error('Unable to determine ArtThread field offsets');\n    }\n\n    spec = {\n      offset: {\n        isExceptionReportedToInstrumentation: isExceptionReportedOffset,\n        exception: exceptionOffset,\n        throwLocation: throwLocationOffset,\n        topHandleScope: topHandleScopeOffset,\n        managedStack: managedStackOffset,\n        self: selfOffset\n      }\n    };\n  });\n\n  return spec;\n}\n\nfunction _getArtManagedStackSpec () {\n  const apiLevel = getAndroidApiLevel();\n\n  if (apiLevel >= 23) {\n    return {\n      offset: {\n        topQuickFrame: 0,\n        link: pointerSize\n      }\n    };\n  } else {\n    return {\n      offset: {\n        topQuickFrame: 2 * pointerSize,\n        link: 0\n      }\n    };\n  }\n}\n\nconst artQuickTrampolineParsers = {\n  ia32: parseArtQuickTrampolineX86,\n  x64: parseArtQuickTrampolineX86,\n  arm: parseArtQuickTrampolineArm,\n  arm64: parseArtQuickTrampolineArm64\n};\n\nfunction getArtQuickEntrypointFromTrampoline (trampoline, vm) {\n  let address;\n\n  vm.perform(env => {\n    const thread = getArtThreadFromEnv(env);\n\n    const tryParse = artQuickTrampolineParsers[Process.arch];\n\n    const insn = Instruction.parse(trampoline);\n\n    const offset = tryParse(insn);\n    if (offset !== null) {\n      address = thread.add(offset).readPointer();\n    } else {\n      address = trampoline;\n    }\n  });\n\n  return address;\n}\n\nfunction parseArtQuickTrampolineX86 (insn) {\n  if (insn.mnemonic === 'jmp') {\n    return insn.operands[0].value.disp;\n  }\n\n  return null;\n}\n\nfunction parseArtQuickTrampolineArm (insn) {\n  if (insn.mnemonic === 'ldr.w') {\n    return insn.operands[1].value.disp;\n  }\n\n  return null;\n}\n\nfunction parseArtQuickTrampolineArm64 (insn) {\n  if (insn.mnemonic === 'ldr') {\n    return insn.operands[1].value.disp;\n  }\n\n  return null;\n}\n\nfunction getArtThreadFromEnv (env) {\n  return env.handle.add(pointerSize).readPointer();\n}\n\nfunction _getAndroidVersion () {\n  return getAndroidSystemProperty('ro.build.version.release');\n}\n\nfunction _getAndroidCodename () {\n  return getAndroidSystemProperty('ro.build.version.codename');\n}\n\nfunction _getAndroidApiLevel () {\n  return parseInt(getAndroidSystemProperty('ro.build.version.sdk'), 10);\n}\n\nlet systemPropertyGet = null;\nconst PROP_VALUE_MAX = 92;\n\nfunction getAndroidSystemProperty (name) {\n  if (systemPropertyGet === null) {\n    systemPropertyGet = new NativeFunction(Module.getExportByName('libc.so', '__system_property_get'), 'int', ['pointer', 'pointer'], nativeFunctionOptions);\n  }\n  const buf = Memory.alloc(PROP_VALUE_MAX);\n  systemPropertyGet(Memory.allocUtf8String(name), buf);\n  return buf.readUtf8String();\n}\n\nfunction withRunnableArtThread (vm, env, fn) {\n  const perform = getArtThreadStateTransitionImpl(vm, env);\n\n  const id = getArtThreadFromEnv(env).toString();\n  artThreadStateTransitions[id] = fn;\n\n  perform(env.handle);\n\n  if (artThreadStateTransitions[id] !== undefined) {\n    delete artThreadStateTransitions[id];\n    throw new Error('Unable to perform state transition; please file a bug');\n  }\n}\n\nfunction _getArtThreadStateTransitionImpl (vm, env) {\n  const callback = new NativeCallback(onThreadStateTransitionComplete, 'void', ['pointer']);\n  return makeArtThreadStateTransitionImpl(vm, env, callback);\n}\n\nfunction onThreadStateTransitionComplete (thread) {\n  const id = thread.toString();\n\n  const fn = artThreadStateTransitions[id];\n  delete artThreadStateTransitions[id];\n  fn(thread);\n}\n\nfunction withAllArtThreadsSuspended (fn) {\n  const api = getApi();\n\n  const threadList = api.artThreadList;\n  const longSuspend = false;\n  api['art::ThreadList::SuspendAll'](threadList, Memory.allocUtf8String('frida'), longSuspend ? 1 : 0);\n  try {\n    fn();\n  } finally {\n    api['art::ThreadList::ResumeAll'](threadList);\n  }\n}\n\nclass ArtClassVisitor {\n  constructor (visit) {\n    const visitor = Memory.alloc(4 * pointerSize);\n\n    const vtable = visitor.add(pointerSize);\n    visitor.writePointer(vtable);\n\n    const onVisit = new NativeCallback((self, klass) => {\n      return visit(klass) === true ? 1 : 0;\n    }, 'bool', ['pointer', 'pointer']);\n    vtable.add(2 * pointerSize).writePointer(onVisit);\n\n    this.handle = visitor;\n    this._onVisit = onVisit;\n  }\n}\n\nfunction makeArtClassVisitor (visit) {\n  const api = getApi();\n\n  if (api['art::ClassLinker::VisitClasses'] instanceof NativeFunction) {\n    return new ArtClassVisitor(visit);\n  }\n\n  return new NativeCallback(klass => {\n    return visit(klass) === true ? 1 : 0;\n  }, 'bool', ['pointer', 'pointer']);\n}\n\nclass ArtClassLoaderVisitor {\n  constructor (visit) {\n    const visitor = Memory.alloc(4 * pointerSize);\n\n    const vtable = visitor.add(pointerSize);\n    visitor.writePointer(vtable);\n\n    const onVisit = new NativeCallback((self, klass) => {\n      visit(klass);\n    }, 'void', ['pointer', 'pointer']);\n    vtable.add(2 * pointerSize).writePointer(onVisit);\n\n    this.handle = visitor;\n    this._onVisit = onVisit;\n  }\n}\n\nfunction makeArtClassLoaderVisitor (visit) {\n  return new ArtClassLoaderVisitor(visit);\n}\n\nconst WalkKind = {\n  'include-inlined-frames': 0,\n  'skip-inlined-frames': 1\n};\n\nclass ArtStackVisitor {\n  constructor (thread, context, walkKind, numFrames = 0, checkSuspended = true) {\n    const api = getApi();\n\n    const baseSize = 512; /* Up to 488 bytes on 64-bit Android Q. */\n    const vtableSize = 3 * pointerSize;\n\n    const visitor = Memory.alloc(baseSize + vtableSize);\n\n    api['art::StackVisitor::StackVisitor'](visitor, thread, context, WalkKind[walkKind], numFrames,\n      checkSuspended ? 1 : 0);\n\n    const vtable = visitor.add(baseSize);\n    visitor.writePointer(vtable);\n\n    const onVisitFrame = new NativeCallback(this._visitFrame.bind(this), 'bool', ['pointer']);\n    vtable.add(2 * pointerSize).writePointer(onVisitFrame);\n\n    this.handle = visitor;\n    this._onVisitFrame = onVisitFrame;\n\n    const curShadowFrame = visitor.add((pointerSize === 4) ? 12 : 24);\n    this._curShadowFrame = curShadowFrame;\n    this._curQuickFrame = curShadowFrame.add(pointerSize);\n    this._curQuickFramePc = curShadowFrame.add(2 * pointerSize);\n    this._curOatQuickMethodHeader = curShadowFrame.add(3 * pointerSize);\n\n    this._getMethodImpl = api['art::StackVisitor::GetMethod'];\n    this._descLocImpl = api['art::StackVisitor::DescribeLocation'];\n    this._getCQFIImpl = api['art::StackVisitor::GetCurrentQuickFrameInfo'];\n  }\n\n  walkStack (includeTransitions = false) {\n    getApi()['art::StackVisitor::WalkStack'](this.handle, includeTransitions ? 1 : 0);\n  }\n\n  _visitFrame () {\n    return this.visitFrame() ? 1 : 0;\n  }\n\n  visitFrame () {\n    throw new Error('Subclass must implement visitFrame');\n  }\n\n  getMethod () {\n    const methodHandle = this._getMethodImpl(this.handle);\n    if (methodHandle.isNull()) {\n      return null;\n    }\n    return new ArtMethod(methodHandle);\n  }\n\n  getCurrentQuickFramePc () {\n    return this._curQuickFramePc.readPointer();\n  }\n\n  getCurrentQuickFrame () {\n    return this._curQuickFrame.readPointer();\n  }\n\n  getCurrentShadowFrame () {\n    return this._curShadowFrame.readPointer();\n  }\n\n  describeLocation () {\n    const result = new StdString();\n    this._descLocImpl(result, this.handle);\n    return result.disposeToString();\n  }\n\n  getCurrentOatQuickMethodHeader () {\n    return this._curOatQuickMethodHeader.readPointer();\n  }\n\n  getCurrentQuickFrameInfo () {\n    return this._getCQFIImpl(this.handle);\n  }\n}\n\nclass ArtMethod {\n  constructor (handle) {\n    this.handle = handle;\n  }\n\n  prettyMethod (withSignature = true) {\n    const result = new StdString();\n    getApi()['art::ArtMethod::PrettyMethod'](result, this.handle, withSignature ? 1 : 0);\n    return result.disposeToString();\n  }\n\n  toString () {\n    return `ArtMethod(handle=${this.handle})`;\n  }\n}\n\nfunction makeArtQuickFrameInfoGetter (impl) {\n  return function (self) {\n    const result = Memory.alloc(12);\n\n    getArtQuickFrameInfoGetterThunk(impl)(result, self);\n\n    return {\n      frameSizeInBytes: result.readU32(),\n      coreSpillMask: result.add(4).readU32(),\n      fpSpillMask: result.add(8).readU32()\n    };\n  };\n}\n\nfunction _getArtQuickFrameInfoGetterThunk (impl) {\n  let thunk = NULL;\n  switch (Process.arch) {\n    case 'ia32':\n      thunk = makeThunk(32, writer => {\n        writer.putMovRegRegOffsetPtr('ecx', 'esp', 4); // result\n        writer.putMovRegRegOffsetPtr('edx', 'esp', 8); // self\n        writer.putCallAddressWithArguments(impl, ['ecx', 'edx']);\n\n        // Restore callee's stack frame\n        writer.putMovRegReg('esp', 'ebp');\n        writer.putPopReg('ebp');\n\n        writer.putRet();\n      });\n      break;\n    case 'x64':\n      thunk = makeThunk(32, writer => {\n        writer.putPushReg('rdi'); // preserve result buffer pointer\n        writer.putCallAddressWithArguments(impl, ['rsi']); // self\n        writer.putPopReg('rdi');\n\n        // Struct is stored by value in the rax and edx registers\n        // Write struct to result buffer\n        writer.putMovRegPtrReg('rdi', 'rax');\n        writer.putMovRegOffsetPtrReg('rdi', 8, 'edx');\n\n        writer.putRet();\n      });\n      break;\n    case 'arm':\n      thunk = makeThunk(16, writer => {\n        // By calling convention, we pass a pointer for the result struct\n        writer.putCallAddressWithArguments(impl, ['r0', 'r1']);\n        writer.putPopRegs(['r0', 'lr']);\n        writer.putMovRegReg('pc', 'lr');\n      });\n      break;\n    case 'arm64':\n      thunk = makeThunk(64, writer => {\n        writer.putPushRegReg('x0', 'lr');\n        writer.putCallAddressWithArguments(impl, ['x1']);\n        writer.putPopRegReg('x2', 'lr');\n        writer.putStrRegRegOffset('x0', 'x2', 0);\n        writer.putStrRegRegOffset('w1', 'x2', 8);\n        writer.putRet();\n      });\n      break;\n  }\n  return new NativeFunction(thunk, 'void', ['pointer', 'pointer'], nativeFunctionOptions);\n}\n\nconst thunkRelocators = {\n  ia32: global.X86Relocator,\n  x64: global.X86Relocator,\n  arm: global.ThumbRelocator,\n  arm64: global.Arm64Relocator\n};\n\nconst thunkWriters = {\n  ia32: global.X86Writer,\n  x64: global.X86Writer,\n  arm: global.ThumbWriter,\n  arm64: global.Arm64Writer\n};\n\nfunction makeThunk (size, write) {\n  if (thunkPage === null) {\n    thunkPage = Memory.alloc(Process.pageSize);\n  }\n\n  const thunk = thunkPage.add(thunkOffset);\n\n  const arch = Process.arch;\n\n  const Writer = thunkWriters[arch];\n  Memory.patchCode(thunk, size, code => {\n    const writer = new Writer(code, { pc: thunk });\n    write(writer);\n    writer.flush();\n    if (writer.offset > size) {\n      throw new Error(`Wrote ${writer.offset}, exceeding maximum of ${size}`);\n    }\n  });\n\n  thunkOffset += size;\n\n  return (arch === 'arm') ? thunk.or(1) : thunk;\n}\n\nfunction notifyArtMethodHooked (method, vm) {\n  ensureArtKnowsHowToHandleMethodInstrumentation(vm);\n  ensureArtKnowsHowToHandleReplacementMethods(vm);\n}\n\nfunction makeArtController (vm) {\n  const threadOffsets = getArtThreadSpec(vm).offset;\n  const managedStackOffsets = getArtManagedStackSpec().offset;\n\n  const code = `\n#include <gum/guminterceptor.h>\n\nextern GMutex lock;\nextern GHashTable * methods;\nextern GHashTable * replacements;\nextern gpointer last_seen_art_method;\n\nextern gpointer get_oat_quick_method_header_impl (gpointer method, gpointer pc);\n\nvoid\ninit (void)\n{\n  g_mutex_init (&lock);\n  methods = g_hash_table_new_full (NULL, NULL, NULL, NULL);\n  replacements = g_hash_table_new_full (NULL, NULL, NULL, NULL);\n}\n\nvoid\nfinalize (void)\n{\n  g_hash_table_unref (replacements);\n  g_hash_table_unref (methods);\n  g_mutex_clear (&lock);\n}\n\ngboolean\nis_replacement_method (gpointer method)\n{\n  gboolean is_replacement;\n\n  g_mutex_lock (&lock);\n\n  is_replacement = g_hash_table_contains (replacements, method);\n\n  g_mutex_unlock (&lock);\n\n  return is_replacement;\n}\n\ngpointer\nget_replacement_method (gpointer original_method)\n{\n  gpointer replacement_method;\n\n  g_mutex_lock (&lock);\n\n  replacement_method = g_hash_table_lookup (methods, original_method);\n\n  g_mutex_unlock (&lock);\n\n  return replacement_method;\n}\n\nvoid\nset_replacement_method (gpointer original_method,\n                        gpointer replacement_method)\n{\n  g_mutex_lock (&lock);\n\n  g_hash_table_insert (methods, original_method, replacement_method);\n  g_hash_table_insert (replacements, replacement_method, original_method);\n\n  g_mutex_unlock (&lock);\n}\n\nvoid\ndelete_replacement_method (gpointer original_method)\n{\n  gpointer replacement_method;\n\n  g_mutex_lock (&lock);\n\n  replacement_method = g_hash_table_lookup (methods, original_method);\n  if (replacement_method != NULL)\n  {\n    g_hash_table_remove (methods, original_method);\n    g_hash_table_remove (replacements, replacement_method);\n  }\n\n  g_mutex_unlock (&lock);\n}\n\ngpointer\ntranslate_method (gpointer method)\n{\n  gpointer translated_method;\n\n  g_mutex_lock (&lock);\n\n  translated_method = g_hash_table_lookup (replacements, method);\n\n  g_mutex_unlock (&lock);\n\n  return (translated_method != NULL) ? translated_method : method;\n}\n\ngpointer\nfind_replacement_method_from_quick_code (gpointer method,\n                                         gpointer thread)\n{\n  gpointer replacement_method;\n  gpointer managed_stack;\n  gpointer top_quick_frame;\n  gpointer link_managed_stack;\n  gpointer * link_top_quick_frame;\n\n  replacement_method = get_replacement_method (method);\n  if (replacement_method == NULL)\n    return NULL;\n\n  /*\n   * Stack check.\n   *\n   * Return NULL to indicate that the original method should be invoked, otherwise\n   * return a pointer to the replacement ArtMethod.\n   *\n   * If the caller is our own JNI replacement stub, then a stack transition must\n   * have been pushed onto the current thread's linked list.\n   *\n   * Therefore, we invoke the original method if the following conditions are met:\n   *   1- The current managed stack is empty.\n   *   2- The ArtMethod * inside the linked managed stack's top quick frame is the\n   *      same as our replacement.\n   */\n  managed_stack = thread + ${threadOffsets.managedStack};\n  top_quick_frame = *((gpointer *) (managed_stack + ${managedStackOffsets.topQuickFrame}));\n  if (top_quick_frame != NULL)\n    return replacement_method;\n\n  link_managed_stack = *((gpointer *) (managed_stack + ${managedStackOffsets.link}));\n  if (link_managed_stack == NULL)\n    return replacement_method;\n\n  link_top_quick_frame = GSIZE_TO_POINTER (*((gsize *) (link_managed_stack + ${managedStackOffsets.topQuickFrame})) & ~((gsize) 1));\n  if (link_top_quick_frame == NULL || *link_top_quick_frame != replacement_method)\n    return replacement_method;\n\n  return NULL;\n}\n\nvoid\non_interpreter_do_call (GumInvocationContext * ic)\n{\n  gpointer method, replacement_method;\n\n  method = gum_invocation_context_get_nth_argument (ic, 0);\n\n  replacement_method = get_replacement_method (method);\n  if (replacement_method != NULL)\n    gum_invocation_context_replace_nth_argument (ic, 0, replacement_method);\n}\n\ngpointer\non_art_method_get_oat_quick_method_header (gpointer method,\n                                           gpointer pc)\n{\n  if (is_replacement_method (method))\n    return NULL;\n\n  return get_oat_quick_method_header_impl (method, pc);\n}\n\nvoid\non_art_method_pretty_method (GumInvocationContext * ic)\n{\n  const guint this_arg_index = ${(Process.arch === 'arm64') ? 0 : 1};\n  gpointer method;\n\n  method = gum_invocation_context_get_nth_argument (ic, this_arg_index);\n  if (method == NULL)\n    gum_invocation_context_replace_nth_argument (ic, this_arg_index, last_seen_art_method);\n  else\n    last_seen_art_method = method;\n}\n\nvoid\non_leave_gc_concurrent_copying_copying_phase (GumInvocationContext * ic)\n{\n  GHashTableIter iter;\n  gpointer hooked_method, replacement_method;\n\n  g_mutex_lock (&lock);\n\n  g_hash_table_iter_init (&iter, methods);\n  while (g_hash_table_iter_next (&iter, &hooked_method, &replacement_method))\n    *((uint32_t *) replacement_method) = *((uint32_t *) hooked_method);\n\n  g_mutex_unlock (&lock);\n}\n`;\n\n  const lockSize = 8;\n  const methodsSize = pointerSize;\n  const replacementsSize = pointerSize;\n  const lastSeenArtMethodSize = pointerSize;\n\n  const data = Memory.alloc(lockSize + methodsSize + replacementsSize + lastSeenArtMethodSize);\n\n  const lock = data;\n  const methods = lock.add(lockSize);\n  const replacements = methods.add(methodsSize);\n  const lastSeenArtMethod = replacements.add(replacementsSize);\n\n  const getOatQuickMethodHeaderImpl = Module.findExportByName('libart.so',\n    (pointerSize === 4)\n      ? '_ZN3art9ArtMethod23GetOatQuickMethodHeaderEj'\n      : '_ZN3art9ArtMethod23GetOatQuickMethodHeaderEm');\n\n  const cm = new CModule(code, {\n    lock,\n    methods,\n    replacements,\n    last_seen_art_method: lastSeenArtMethod,\n    get_oat_quick_method_header_impl: getOatQuickMethodHeaderImpl ?? ptr('0xdeadbeef')\n  });\n\n  const fastOptions = { exceptions: 'propagate', scheduling: 'exclusive' };\n\n  return {\n    handle: cm,\n    replacedMethods: {\n      isReplacement: new NativeFunction(cm.is_replacement_method, 'bool', ['pointer'], fastOptions),\n      get: new NativeFunction(cm.get_replacement_method, 'pointer', ['pointer'], fastOptions),\n      set: new NativeFunction(cm.set_replacement_method, 'void', ['pointer', 'pointer'], fastOptions),\n      delete: new NativeFunction(cm.delete_replacement_method, 'void', ['pointer'], fastOptions),\n      translate: new NativeFunction(cm.translate_method, 'pointer', ['pointer'], fastOptions),\n      findReplacementFromQuickCode: cm.find_replacement_method_from_quick_code\n    },\n    getOatQuickMethodHeaderImpl,\n    hooks: {\n      Interpreter: {\n        doCall: cm.on_interpreter_do_call\n      },\n      ArtMethod: {\n        getOatQuickMethodHeader: cm.on_art_method_get_oat_quick_method_header,\n        prettyMethod: cm.on_art_method_pretty_method\n      },\n      Gc: {\n        copyingPhase: {\n          onLeave: cm.on_leave_gc_concurrent_copying_copying_phase\n        },\n        runFlip: {\n          onEnter: cm.on_leave_gc_concurrent_copying_copying_phase\n        }\n      }\n    }\n  };\n}\n\nfunction ensureArtKnowsHowToHandleMethodInstrumentation (vm) {\n  if (taughtArtAboutMethodInstrumentation) {\n    return;\n  }\n  taughtArtAboutMethodInstrumentation = true;\n\n  instrumentArtQuickEntrypoints(vm);\n  instrumentArtMethodInvocationFromInterpreter();\n}\n\nfunction instrumentArtQuickEntrypoints (vm) {\n  const api = getApi();\n\n  // Entrypoints that dispatch method invocation from the quick ABI.\n  const quickEntrypoints = [\n    api.artQuickGenericJniTrampoline,\n    api.artQuickToInterpreterBridge,\n    api.artQuickResolutionTrampoline\n  ];\n\n  quickEntrypoints.forEach(entrypoint => {\n    Memory.protect(entrypoint, 32, 'rwx');\n\n    const interceptor = new ArtQuickCodeInterceptor(entrypoint);\n    interceptor.activate(vm);\n\n    artQuickInterceptors.push(interceptor);\n  });\n}\n\nfunction instrumentArtMethodInvocationFromInterpreter () {\n  const apiLevel = getAndroidApiLevel();\n\n  let artInterpreterDoCallExportRegex;\n  if (apiLevel <= 22) {\n    artInterpreterDoCallExportRegex = /^_ZN3art11interpreter6DoCallILb[0-1]ELb[0-1]EEEbPNS_6mirror9ArtMethodEPNS_6ThreadERNS_11ShadowFrameEPKNS_11InstructionEtPNS_6JValueE$/;\n  } else if (apiLevel <= 33) {\n    artInterpreterDoCallExportRegex = /^_ZN3art11interpreter6DoCallILb[0-1]ELb[0-1]EEEbPNS_9ArtMethodEPNS_6ThreadERNS_11ShadowFrameEPKNS_11InstructionEtPNS_6JValueE$/;\n  } else {\n    artInterpreterDoCallExportRegex = /^_ZN3art11interpreter6DoCallILb[0-1]EEEbPNS_9ArtMethodEPNS_6ThreadERNS_11ShadowFrameEPKNS_11InstructionEtbPNS_6JValueE$/;\n  }\n\n  for (const exp of Module.enumerateExports('libart.so').filter(exp => artInterpreterDoCallExportRegex.test(exp.name))) {\n    Interceptor.attach(exp.address, artController.hooks.Interpreter.doCall);\n  }\n}\n\nfunction ensureArtKnowsHowToHandleReplacementMethods (vm) {\n  if (taughtArtAboutReplacementMethods) {\n    return;\n  }\n  taughtArtAboutReplacementMethods = true;\n\n  if (!maybeInstrumentGetOatQuickMethodHeaderInlineCopies()) {\n    const { getOatQuickMethodHeaderImpl } = artController;\n    if (getOatQuickMethodHeaderImpl === null) {\n      return;\n    }\n\n    try {\n      Interceptor.replace(getOatQuickMethodHeaderImpl, artController.hooks.ArtMethod.getOatQuickMethodHeader);\n    } catch (e) {\n      /*\n       * Already replaced by another script. For now we don't support replacing methods from multiple scripts,\n       * but we'll allow users to try it if they're feeling adventurous.\n       */\n    }\n  }\n\n  const apiLevel = getAndroidApiLevel();\n\n  let copyingPhase = null;\n  if (apiLevel > 28) {\n    copyingPhase = Module.findExportByName('libart.so', '_ZN3art2gc9collector17ConcurrentCopying12CopyingPhaseEv');\n  } else if (apiLevel > 22) {\n    copyingPhase = Module.findExportByName('libart.so', '_ZN3art2gc9collector17ConcurrentCopying12MarkingPhaseEv');\n  }\n  if (copyingPhase !== null) {\n    Interceptor.attach(copyingPhase, artController.hooks.Gc.copyingPhase);\n  }\n  \n  let runFlip = null;\n  runFlip = Module.findExportByName('libart.so', '_ZN3art6Thread15RunFlipFunctionEPS0_b');\n  if (runFlip === null) {\n    runFlip = Module.findExportByName('libart.so', '_ZN3art6Thread15RunFlipFunctionEPS0'); // api 35\n  }\n  if (runFlip !== null) {\n    Interceptor.attach(runFlip, artController.hooks.Gc.runFlip);\n   }\n}\n\nconst artGetOatQuickMethodHeaderInlinedCopyHandler = {\n  arm: {\n    signatures: [\n      {\n        pattern: [\n          'b0 68', // ldr r0, [r6, #8]\n          '01 30', // adds r0, #1\n          '0c d0', // beq #0x16fcd4\n          '1b 98', // ldr r0, [sp, #0x6c]\n          ':',\n          'c0 ff',\n          'c0 ff',\n          '00 ff',\n          '00 2f'\n        ],\n        validateMatch: validateGetOatQuickMethodHeaderInlinedMatchArm\n      },\n      {\n        pattern: [\n          'd8 f8 08 00', // ldr r0, [r8, #8]\n          '01 30', // adds r0, #1\n          '0c d0', // beq #0x16fcd4\n          '1b 98', // ldr r0, [sp, #0x6c]\n          ':',\n          'f0 ff ff 0f',\n          'ff ff',\n          '00 ff',\n          '00 2f'\n        ],\n        validateMatch: validateGetOatQuickMethodHeaderInlinedMatchArm\n      },\n      {\n        pattern: [\n          'b0 68', // ldr r0, [r6, #8]\n          '01 30', // adds r0, #1\n          '40 f0 c3 80', // bne #0x203bf0\n          '00 25', // movs r5, #0\n          ':',\n          'c0 ff',\n          'c0 ff',\n          'c0 fb 00 d0',\n          'ff f8'\n        ],\n        validateMatch: validateGetOatQuickMethodHeaderInlinedMatchArm\n      }\n    ],\n    instrument: instrumentGetOatQuickMethodHeaderInlinedCopyArm\n  },\n  arm64: {\n    signatures: [\n      {\n        pattern: [\n          /* e8 */ '0a 40 b9', // ldr w8, [x23, #0x8]\n          '1f 05 00 31', // cmn w8, #0x1\n          '40 01 00 54', // b.eq 0x2e4204\n          '88 39 00 f0', // adrp x8, 0xa17000\n          ':',\n          /* 00 */ 'fc ff ff',\n          '1f fc ff ff',\n          '1f 00 00 ff',\n          '00 00 00 9f'\n        ],\n        offset: 1,\n        validateMatch: validateGetOatQuickMethodHeaderInlinedMatchArm64\n      },\n      {\n        pattern: [\n          /* e8 */ '0a 40 b9', // ldr w8, [x23, #0x8]\n          '1f 05 00 31', // cmn w8, #0x1\n          '01 34 00 54', // b.ne 0x3d8e50\n          'e0 03 1f aa', // mov x0, xzr\n          ':',\n          /* 00 */ 'fc ff ff',\n          '1f fc ff ff',\n          '1f 00 00 ff',\n          'e0 ff ff ff'\n        ],\n        offset: 1,\n        validateMatch: validateGetOatQuickMethodHeaderInlinedMatchArm64\n      }\n    ],\n    instrument: instrumentGetOatQuickMethodHeaderInlinedCopyArm64\n  }\n};\n\nfunction validateGetOatQuickMethodHeaderInlinedMatchArm ({ address, size }) {\n  const ldr = Instruction.parse(address.or(1));\n  const [ldrDst, ldrSrc] = ldr.operands;\n  const methodReg = ldrSrc.value.base;\n  const scratchReg = ldrDst.value;\n\n  const branch = Instruction.parse(ldr.next.add(2));\n  const targetWhenTrue = ptr(branch.operands[0].value);\n  const targetWhenFalse = branch.address.add(branch.size);\n\n  let targetWhenRegularMethod, targetWhenRuntimeMethod;\n  if (branch.mnemonic === 'beq') {\n    targetWhenRegularMethod = targetWhenFalse;\n    targetWhenRuntimeMethod = targetWhenTrue;\n  } else {\n    targetWhenRegularMethod = targetWhenTrue;\n    targetWhenRuntimeMethod = targetWhenFalse;\n  }\n\n  return parseInstructionsAt(targetWhenRegularMethod.or(1), tryParse, { limit: 3 });\n\n  function tryParse (insn) {\n    const { mnemonic } = insn;\n    if (!(mnemonic === 'ldr' || mnemonic === 'ldr.w')) {\n      return null;\n    }\n\n    const { base, disp } = insn.operands[1].value;\n    if (!(base === methodReg && disp === 0x14)) {\n      return null;\n    }\n\n    return {\n      methodReg,\n      scratchReg,\n      target: {\n        whenTrue: targetWhenTrue,\n        whenRegularMethod: targetWhenRegularMethod,\n        whenRuntimeMethod: targetWhenRuntimeMethod\n      }\n    };\n  }\n}\n\nfunction validateGetOatQuickMethodHeaderInlinedMatchArm64 ({ address, size }) {\n  const [ldrDst, ldrSrc] = Instruction.parse(address).operands;\n  const methodReg = ldrSrc.value.base;\n  const scratchReg = 'x' + ldrDst.value.substring(1);\n\n  const branch = Instruction.parse(address.add(8));\n  const targetWhenTrue = ptr(branch.operands[0].value);\n  const targetWhenFalse = address.add(12);\n\n  let targetWhenRegularMethod, targetWhenRuntimeMethod;\n  if (branch.mnemonic === 'b.eq') {\n    targetWhenRegularMethod = targetWhenFalse;\n    targetWhenRuntimeMethod = targetWhenTrue;\n  } else {\n    targetWhenRegularMethod = targetWhenTrue;\n    targetWhenRuntimeMethod = targetWhenFalse;\n  }\n\n  return parseInstructionsAt(targetWhenRegularMethod, tryParse, { limit: 3 });\n\n  function tryParse (insn) {\n    if (insn.mnemonic !== 'ldr') {\n      return null;\n    }\n\n    const { base, disp } = insn.operands[1].value;\n    if (!(base === methodReg && disp === 0x18)) {\n      return null;\n    }\n\n    return {\n      methodReg,\n      scratchReg,\n      target: {\n        whenTrue: targetWhenTrue,\n        whenRegularMethod: targetWhenRegularMethod,\n        whenRuntimeMethod: targetWhenRuntimeMethod\n      }\n    };\n  }\n}\n\nfunction maybeInstrumentGetOatQuickMethodHeaderInlineCopies () {\n  if (getAndroidApiLevel() < 31) {\n    return false;\n  }\n\n  const handler = artGetOatQuickMethodHeaderInlinedCopyHandler[Process.arch];\n  if (handler === undefined) {\n    // Not needed on x86 and x64, at least not for now...\n    return false;\n  }\n\n  const signatures = handler.signatures.map(({ pattern, offset = 0, validateMatch = returnEmptyObject }) => {\n    return {\n      pattern: new MatchPattern(pattern.join('')),\n      offset,\n      validateMatch\n    };\n  });\n\n  const impls = [];\n  for (const { base, size } of getApi().module.enumerateRanges('--x')) {\n    for (const { pattern, offset, validateMatch } of signatures) {\n      const matches = Memory.scanSync(base, size, pattern)\n        .map(({ address, size }) => {\n          return { address: address.sub(offset), size: size + offset };\n        })\n        .filter(match => {\n          const validationResult = validateMatch(match);\n          if (validationResult === null) {\n            return false;\n          }\n          match.validationResult = validationResult;\n          return true;\n        });\n      impls.push(...matches);\n    }\n  }\n\n  if (impls.length === 0) {\n    return false;\n  }\n\n  impls.forEach(handler.instrument);\n\n  return true;\n}\n\nfunction returnEmptyObject () {\n  return {};\n}\n\nclass InlineHook {\n  constructor (address, size, trampoline) {\n    this.address = address;\n    this.size = size;\n    this.originalCode = address.readByteArray(size);\n    this.trampoline = trampoline;\n  }\n\n  revert () {\n    Memory.patchCode(this.address, this.size, code => {\n      code.writeByteArray(this.originalCode);\n    });\n  }\n}\n\nfunction instrumentGetOatQuickMethodHeaderInlinedCopyArm ({ address, size, validationResult }) {\n  const { methodReg, target } = validationResult;\n\n  const trampoline = Memory.alloc(Process.pageSize);\n  let redirectCapacity = size;\n\n  Memory.patchCode(trampoline, 256, code => {\n    const writer = new ThumbWriter(code, { pc: trampoline });\n\n    const relocator = new ThumbRelocator(address, writer);\n    for (let i = 0; i !== 2; i++) {\n      relocator.readOne();\n    }\n    relocator.writeAll();\n\n    relocator.readOne();\n    relocator.skipOne();\n    writer.putBCondLabel('eq', 'runtime_or_replacement_method');\n\n    const vpushFpRegs = [0x2d, 0xed, 0x10, 0x0a]; /* vpush {s0-s15} */\n    writer.putBytes(vpushFpRegs);\n\n    const savedRegs = ['r0', 'r1', 'r2', 'r3'];\n    writer.putPushRegs(savedRegs);\n\n    writer.putCallAddressWithArguments(artController.replacedMethods.isReplacement, [methodReg]);\n    writer.putCmpRegImm('r0', 0);\n\n    writer.putPopRegs(savedRegs);\n\n    const vpopFpRegs = [0xbd, 0xec, 0x10, 0x0a]; /* vpop {s0-s15} */\n    writer.putBytes(vpopFpRegs);\n\n    writer.putBCondLabel('ne', 'runtime_or_replacement_method');\n    writer.putBLabel('regular_method');\n\n    relocator.readOne();\n\n    const tailIsRegular = relocator.input.address.equals(target.whenRegularMethod);\n\n    writer.putLabel(tailIsRegular ? 'regular_method' : 'runtime_or_replacement_method');\n    relocator.writeOne();\n    while (redirectCapacity < 10) {\n      const offset = relocator.readOne();\n      if (offset === 0) {\n        redirectCapacity = 10;\n        break;\n      }\n      redirectCapacity = offset;\n    }\n    relocator.writeAll();\n    writer.putBranchAddress(address.add(redirectCapacity + 1));\n\n    writer.putLabel(tailIsRegular ? 'runtime_or_replacement_method' : 'regular_method');\n    writer.putBranchAddress(target.whenTrue);\n\n    writer.flush();\n  });\n\n  inlineHooks.push(new InlineHook(address, redirectCapacity, trampoline));\n\n  Memory.patchCode(address, redirectCapacity, code => {\n    const writer = new ThumbWriter(code, { pc: address });\n    writer.putLdrRegAddress('pc', trampoline.or(1));\n    writer.flush();\n  });\n}\n\nfunction instrumentGetOatQuickMethodHeaderInlinedCopyArm64 ({ address, size, validationResult }) {\n  const { methodReg, scratchReg, target } = validationResult;\n\n  const trampoline = Memory.alloc(Process.pageSize);\n\n  Memory.patchCode(trampoline, 256, code => {\n    const writer = new Arm64Writer(code, { pc: trampoline });\n\n    const relocator = new Arm64Relocator(address, writer);\n    for (let i = 0; i !== 2; i++) {\n      relocator.readOne();\n    }\n    relocator.writeAll();\n\n    relocator.readOne();\n    relocator.skipOne();\n    writer.putBCondLabel('eq', 'runtime_or_replacement_method');\n\n    const savedRegs = [\n      'd0', 'd1',\n      'd2', 'd3',\n      'd4', 'd5',\n      'd6', 'd7',\n      'x0', 'x1',\n      'x2', 'x3',\n      'x4', 'x5',\n      'x6', 'x7',\n      'x8', 'x9',\n      'x10', 'x11',\n      'x12', 'x13',\n      'x14', 'x15',\n      'x16', 'x17'\n    ];\n    const numSavedRegs = savedRegs.length;\n\n    for (let i = 0; i !== numSavedRegs; i += 2) {\n      writer.putPushRegReg(savedRegs[i], savedRegs[i + 1]);\n    }\n\n    writer.putCallAddressWithArguments(artController.replacedMethods.isReplacement, [methodReg]);\n    writer.putCmpRegReg('x0', 'xzr');\n\n    for (let i = numSavedRegs - 2; i >= 0; i -= 2) {\n      writer.putPopRegReg(savedRegs[i], savedRegs[i + 1]);\n    }\n\n    writer.putBCondLabel('ne', 'runtime_or_replacement_method');\n    writer.putBLabel('regular_method');\n\n    relocator.readOne();\n    const tailInstruction = relocator.input;\n\n    const tailIsRegular = tailInstruction.address.equals(target.whenRegularMethod);\n\n    writer.putLabel(tailIsRegular ? 'regular_method' : 'runtime_or_replacement_method');\n    relocator.writeOne();\n    writer.putBranchAddress(tailInstruction.next);\n\n    writer.putLabel(tailIsRegular ? 'runtime_or_replacement_method' : 'regular_method');\n    writer.putBranchAddress(target.whenTrue);\n\n    writer.flush();\n  });\n\n  inlineHooks.push(new InlineHook(address, size, trampoline));\n\n  Memory.patchCode(address, size, code => {\n    const writer = new Arm64Writer(code, { pc: address });\n    writer.putLdrRegAddress(scratchReg, trampoline);\n    writer.putBrReg(scratchReg);\n    writer.flush();\n  });\n}\n\nfunction makeMethodMangler (methodId) {\n  return new MethodMangler(methodId);\n}\n\nfunction translateMethod (methodId) {\n  return artController.replacedMethods.translate(methodId);\n}\n\nfunction backtrace (vm, options = {}) {\n  const { limit = 16 } = options;\n\n  const env = vm.getEnv();\n\n  if (backtraceModule === null) {\n    backtraceModule = makeBacktraceModule(vm, env);\n  }\n\n  return backtraceModule.backtrace(env, limit);\n}\n\nfunction makeBacktraceModule (vm, env) {\n  const api = getApi();\n\n  const performImpl = Memory.alloc(Process.pointerSize);\n\n  const cm = new CModule(`\n#include <glib.h>\n#include <stdbool.h>\n#include <string.h>\n#include <gum/gumtls.h>\n#include <json-glib/json-glib.h>\n\ntypedef struct _ArtBacktrace ArtBacktrace;\ntypedef struct _ArtStackFrame ArtStackFrame;\n\ntypedef struct _ArtStackVisitor ArtStackVisitor;\ntypedef struct _ArtStackVisitorVTable ArtStackVisitorVTable;\n\ntypedef struct _ArtClass ArtClass;\ntypedef struct _ArtMethod ArtMethod;\ntypedef struct _ArtThread ArtThread;\ntypedef struct _ArtContext ArtContext;\n\ntypedef struct _JNIEnv JNIEnv;\n\ntypedef struct _StdString StdString;\ntypedef struct _StdTinyString StdTinyString;\ntypedef struct _StdLargeString StdLargeString;\n\ntypedef enum {\n  STACK_WALK_INCLUDE_INLINED_FRAMES,\n  STACK_WALK_SKIP_INLINED_FRAMES,\n} StackWalkKind;\n\nstruct _StdTinyString\n{\n  guint8 unused;\n  gchar data[(3 * sizeof (gpointer)) - 1];\n};\n\nstruct _StdLargeString\n{\n  gsize capacity;\n  gsize size;\n  gchar * data;\n};\n\nstruct _StdString\n{\n  union\n  {\n    guint8 flags;\n    StdTinyString tiny;\n    StdLargeString large;\n  };\n};\n\nstruct _ArtBacktrace\n{\n  GChecksum * id;\n  GArray * frames;\n  gchar * frames_json;\n};\n\nstruct _ArtStackFrame\n{\n  ArtMethod * method;\n  gsize dexpc;\n  StdString description;\n};\n\nstruct _ArtStackVisitorVTable\n{\n  void (* unused1) (void);\n  void (* unused2) (void);\n  bool (* visit) (ArtStackVisitor * visitor);\n};\n\nstruct _ArtStackVisitor\n{\n  ArtStackVisitorVTable * vtable;\n\n  guint8 padding[512];\n\n  ArtStackVisitorVTable vtable_storage;\n\n  ArtBacktrace * backtrace;\n};\n\nstruct _ArtMethod\n{\n  guint32 declaring_class;\n  guint32 access_flags;\n};\n\nextern GumTlsKey current_backtrace;\n\nextern void (* perform_art_thread_state_transition) (JNIEnv * env);\n\nextern ArtContext * art_thread_get_long_jump_context (ArtThread * thread);\n\nextern void art_stack_visitor_init (ArtStackVisitor * visitor, ArtThread * thread, void * context, StackWalkKind walk_kind,\n    size_t num_frames, bool check_suspended);\nextern void art_stack_visitor_walk_stack (ArtStackVisitor * visitor, bool include_transitions);\nextern ArtMethod * art_stack_visitor_get_method (ArtStackVisitor * visitor);\nextern void art_stack_visitor_describe_location (StdString * description, ArtStackVisitor * visitor);\nextern ArtMethod * translate_method (ArtMethod * method);\nextern void translate_location (ArtMethod * method, guint32 pc, const gchar ** source_file, gint32 * line_number);\nextern void get_class_location (StdString * result, ArtClass * klass);\nextern void cxx_delete (void * mem);\nextern unsigned long strtoul (const char * str, char ** endptr, int base);\n\nstatic bool visit_frame (ArtStackVisitor * visitor);\nstatic void art_stack_frame_destroy (ArtStackFrame * frame);\n\nstatic void append_jni_type_name (GString * s, const gchar * name, gsize length);\n\nstatic void std_string_destroy (StdString * str);\nstatic gchar * std_string_get_data (StdString * str);\n\nvoid\ninit (void)\n{\n  current_backtrace = gum_tls_key_new ();\n}\n\nvoid\nfinalize (void)\n{\n  gum_tls_key_free (current_backtrace);\n}\n\nArtBacktrace *\n_create (JNIEnv * env,\n         guint limit)\n{\n  ArtBacktrace * bt;\n\n  bt = g_new (ArtBacktrace, 1);\n  bt->id = g_checksum_new (G_CHECKSUM_SHA1);\n  bt->frames = (limit != 0)\n      ? g_array_sized_new (FALSE, FALSE, sizeof (ArtStackFrame), limit)\n      : g_array_new (FALSE, FALSE, sizeof (ArtStackFrame));\n  g_array_set_clear_func (bt->frames, (GDestroyNotify) art_stack_frame_destroy);\n  bt->frames_json = NULL;\n\n  gum_tls_key_set_value (current_backtrace, bt);\n\n  perform_art_thread_state_transition (env);\n\n  gum_tls_key_set_value (current_backtrace, NULL);\n\n  return bt;\n}\n\nvoid\n_on_thread_state_transition_complete (ArtThread * thread)\n{\n  ArtContext * context;\n  ArtStackVisitor visitor = {\n    .vtable_storage = {\n      .visit = visit_frame,\n    },\n  };\n\n  context = art_thread_get_long_jump_context (thread);\n\n  art_stack_visitor_init (&visitor, thread, context, STACK_WALK_SKIP_INLINED_FRAMES, 0, true);\n  visitor.vtable = &visitor.vtable_storage;\n  visitor.backtrace = gum_tls_key_get_value (current_backtrace);\n\n  art_stack_visitor_walk_stack (&visitor, false);\n\n  cxx_delete (context);\n}\n\nstatic bool\nvisit_frame (ArtStackVisitor * visitor)\n{\n  ArtBacktrace * bt = visitor->backtrace;\n  ArtStackFrame frame;\n  const gchar * description, * dexpc_part;\n\n  frame.method = art_stack_visitor_get_method (visitor);\n\n  art_stack_visitor_describe_location (&frame.description, visitor);\n\n  description = std_string_get_data (&frame.description);\n  if (strstr (description, \" '<\") != NULL)\n    goto skip;\n\n  dexpc_part = strstr (description, \" at dex PC 0x\");\n  if (dexpc_part == NULL)\n    goto skip;\n  frame.dexpc = strtoul (dexpc_part + 13, NULL, 16);\n\n  g_array_append_val (bt->frames, frame);\n\n  g_checksum_update (bt->id, (guchar *) &frame.method, sizeof (frame.method));\n  g_checksum_update (bt->id, (guchar *) &frame.dexpc, sizeof (frame.dexpc));\n\n  return true;\n\nskip:\n  std_string_destroy (&frame.description);\n  return true;\n}\n\nstatic void\nart_stack_frame_destroy (ArtStackFrame * frame)\n{\n  std_string_destroy (&frame->description);\n}\n\nvoid\n_destroy (ArtBacktrace * backtrace)\n{\n  g_free (backtrace->frames_json);\n  g_array_free (backtrace->frames, TRUE);\n  g_checksum_free (backtrace->id);\n  g_free (backtrace);\n}\n\nconst gchar *\n_get_id (ArtBacktrace * backtrace)\n{\n  return g_checksum_get_string (backtrace->id);\n}\n\nconst gchar *\n_get_frames (ArtBacktrace * backtrace)\n{\n  GArray * frames = backtrace->frames;\n  JsonBuilder * b;\n  guint i;\n  JsonNode * root;\n\n  if (backtrace->frames_json != NULL)\n    return backtrace->frames_json;\n\n  b = json_builder_new_immutable ();\n\n  json_builder_begin_array (b);\n\n  for (i = 0; i != frames->len; i++)\n  {\n    ArtStackFrame * frame = &g_array_index (frames, ArtStackFrame, i);\n    gchar * description, * ret_type, * paren_open, * paren_close, * arg_types, * token, * method_name, * class_name;\n    GString * signature;\n    gchar * cursor;\n    ArtMethod * translated_method;\n    StdString location;\n    gsize dexpc;\n    const gchar * source_file;\n    gint32 line_number;\n\n    description = std_string_get_data (&frame->description);\n\n    ret_type = strchr (description, '\\'') + 1;\n\n    paren_open = strchr (ret_type, '(');\n    paren_close = strchr (paren_open, ')');\n    *paren_open = '\\0';\n    *paren_close = '\\0';\n\n    arg_types = paren_open + 1;\n\n    token = strrchr (ret_type, '.');\n    *token = '\\0';\n\n    method_name = token + 1;\n\n    token = strrchr (ret_type, ' ');\n    *token = '\\0';\n\n    class_name = token + 1;\n\n    signature = g_string_sized_new (128);\n\n    append_jni_type_name (signature, class_name, method_name - class_name - 1);\n    g_string_append_c (signature, ',');\n    g_string_append (signature, method_name);\n    g_string_append (signature, \",(\");\n\n    if (arg_types != paren_close)\n    {\n      for (cursor = arg_types; cursor != NULL;)\n      {\n        gsize length;\n        gchar * next;\n\n        token = strstr (cursor, \", \");\n        if (token != NULL)\n        {\n          length = token - cursor;\n          next = token + 2;\n        }\n        else\n        {\n          length = paren_close - cursor;\n          next = NULL;\n        }\n\n        append_jni_type_name (signature, cursor, length);\n\n        cursor = next;\n      }\n    }\n\n    g_string_append_c (signature, ')');\n\n    append_jni_type_name (signature, ret_type, class_name - ret_type - 1);\n\n    translated_method = translate_method (frame->method);\n    dexpc = (translated_method == frame->method) ? frame->dexpc : 0;\n\n    get_class_location (&location, GSIZE_TO_POINTER (translated_method->declaring_class));\n\n    translate_location (translated_method, dexpc, &source_file, &line_number);\n\n    json_builder_begin_object (b);\n\n    json_builder_set_member_name (b, \"signature\");\n    json_builder_add_string_value (b, signature->str);\n\n    json_builder_set_member_name (b, \"origin\");\n    json_builder_add_string_value (b, std_string_get_data (&location));\n\n    json_builder_set_member_name (b, \"className\");\n    json_builder_add_string_value (b, class_name);\n\n    json_builder_set_member_name (b, \"methodName\");\n    json_builder_add_string_value (b, method_name);\n\n    json_builder_set_member_name (b, \"methodFlags\");\n    json_builder_add_int_value (b, translated_method->access_flags);\n\n    json_builder_set_member_name (b, \"fileName\");\n    json_builder_add_string_value (b, source_file);\n\n    json_builder_set_member_name (b, \"lineNumber\");\n    json_builder_add_int_value (b, line_number);\n\n    json_builder_end_object (b);\n\n    std_string_destroy (&location);\n    g_string_free (signature, TRUE);\n  }\n\n  json_builder_end_array (b);\n\n  root = json_builder_get_root (b);\n  backtrace->frames_json = json_to_string (root, FALSE);\n  json_node_unref (root);\n\n  return backtrace->frames_json;\n}\n\nstatic void\nappend_jni_type_name (GString * s,\n                      const gchar * name,\n                      gsize length)\n{\n  gchar shorty = '\\0';\n  gsize i;\n\n  switch (name[0])\n  {\n    case 'b':\n      if (strncmp (name, \"boolean\", length) == 0)\n        shorty = 'Z';\n      else if (strncmp (name, \"byte\", length) == 0)\n        shorty = 'B';\n      break;\n    case 'c':\n      if (strncmp (name, \"char\", length) == 0)\n        shorty = 'C';\n      break;\n    case 'd':\n      if (strncmp (name, \"double\", length) == 0)\n        shorty = 'D';\n      break;\n    case 'f':\n      if (strncmp (name, \"float\", length) == 0)\n        shorty = 'F';\n      break;\n    case 'i':\n      if (strncmp (name, \"int\", length) == 0)\n        shorty = 'I';\n      break;\n    case 'l':\n      if (strncmp (name, \"long\", length) == 0)\n        shorty = 'J';\n      break;\n    case 's':\n      if (strncmp (name, \"short\", length) == 0)\n        shorty = 'S';\n      break;\n    case 'v':\n      if (strncmp (name, \"void\", length) == 0)\n        shorty = 'V';\n      break;\n  }\n\n  if (shorty != '\\0')\n  {\n    g_string_append_c (s, shorty);\n\n    return;\n  }\n\n  if (length > 2 && name[length - 2] == '[' && name[length - 1] == ']')\n  {\n    g_string_append_c (s, '[');\n    append_jni_type_name (s, name, length - 2);\n\n    return;\n  }\n\n  g_string_append_c (s, 'L');\n\n  for (i = 0; i != length; i++)\n  {\n    gchar ch = name[i];\n    if (ch != '.')\n      g_string_append_c (s, ch);\n    else\n      g_string_append_c (s, '/');\n  }\n\n  g_string_append_c (s, ';');\n}\n\nstatic void\nstd_string_destroy (StdString * str)\n{\n  bool is_large = (str->flags & 1) != 0;\n  if (is_large)\n    cxx_delete (str->large.data);\n}\n\nstatic gchar *\nstd_string_get_data (StdString * str)\n{\n  bool is_large = (str->flags & 1) != 0;\n  return is_large ? str->large.data : str->tiny.data;\n}\n`, {\n    current_backtrace: Memory.alloc(Process.pointerSize),\n    perform_art_thread_state_transition: performImpl,\n    art_thread_get_long_jump_context: api['art::Thread::GetLongJumpContext'],\n    art_stack_visitor_init: api['art::StackVisitor::StackVisitor'],\n    art_stack_visitor_walk_stack: api['art::StackVisitor::WalkStack'],\n    art_stack_visitor_get_method: api['art::StackVisitor::GetMethod'],\n    art_stack_visitor_describe_location: api['art::StackVisitor::DescribeLocation'],\n    translate_method: artController.replacedMethods.translate,\n    translate_location: api['art::Monitor::TranslateLocation'],\n    get_class_location: api['art::mirror::Class::GetLocation'],\n    cxx_delete: api.$delete,\n    strtoul: Module.getExportByName('libc.so', 'strtoul')\n  });\n\n  const _create = new NativeFunction(cm._create, 'pointer', ['pointer', 'uint'], nativeFunctionOptions);\n  const _destroy = new NativeFunction(cm._destroy, 'void', ['pointer'], nativeFunctionOptions);\n\n  const fastOptions = { exceptions: 'propagate', scheduling: 'exclusive' };\n  const _getId = new NativeFunction(cm._get_id, 'pointer', ['pointer'], fastOptions);\n  const _getFrames = new NativeFunction(cm._get_frames, 'pointer', ['pointer'], fastOptions);\n\n  const performThreadStateTransition = makeArtThreadStateTransitionImpl(vm, env, cm._on_thread_state_transition_complete);\n  cm._performData = performThreadStateTransition;\n  performImpl.writePointer(performThreadStateTransition);\n\n  cm.backtrace = (env, limit) => {\n    const handle = _create(env, limit);\n    const bt = new Backtrace(handle);\n    Script.bindWeak(bt, destroy.bind(null, handle));\n    return bt;\n  };\n\n  function destroy (handle) {\n    _destroy(handle);\n  }\n\n  cm.getId = handle => {\n    return _getId(handle).readUtf8String();\n  };\n\n  cm.getFrames = handle => {\n    return JSON.parse(_getFrames(handle).readUtf8String());\n  };\n\n  return cm;\n}\n\nclass Backtrace {\n  constructor (handle) {\n    this.handle = handle;\n  }\n\n  get id () {\n    return backtraceModule.getId(this.handle);\n  }\n\n  get frames () {\n    return backtraceModule.getFrames(this.handle);\n  }\n}\n\nfunction revertGlobalPatches () {\n  patchedClasses.forEach(entry => {\n    entry.vtablePtr.writePointer(entry.vtable);\n    entry.vtableCountPtr.writeS32(entry.vtableCount);\n  });\n  patchedClasses.clear();\n\n  for (const interceptor of artQuickInterceptors.splice(0)) {\n    interceptor.deactivate();\n  }\n\n  for (const hook of inlineHooks.splice(0)) {\n    hook.revert();\n  }\n}\n\nfunction unwrapMethodId (methodId) {\n  const api = getApi();\n\n  const runtimeOffset = getArtRuntimeSpec(api).offset;\n  const jniIdManagerOffset = runtimeOffset.jniIdManager;\n  const jniIdsIndirectionOffset = runtimeOffset.jniIdsIndirection;\n\n  if (jniIdManagerOffset !== null && jniIdsIndirectionOffset !== null) {\n    const runtime = api.artRuntime;\n\n    const jniIdsIndirection = runtime.add(jniIdsIndirectionOffset).readInt();\n\n    if (jniIdsIndirection !== kPointer) {\n      const jniIdManager = runtime.add(jniIdManagerOffset).readPointer();\n      return api['art::jni::JniIdManager::DecodeMethodId'](jniIdManager, methodId);\n    }\n  }\n\n  return methodId;\n}\n\nconst artQuickCodeReplacementTrampolineWriters = {\n  ia32: writeArtQuickCodeReplacementTrampolineIA32,\n  x64: writeArtQuickCodeReplacementTrampolineX64,\n  arm: writeArtQuickCodeReplacementTrampolineArm,\n  arm64: writeArtQuickCodeReplacementTrampolineArm64\n};\n\nfunction writeArtQuickCodeReplacementTrampolineIA32 (trampoline, target, redirectSize, constraints, vm) {\n  const threadOffsets = getArtThreadSpec(vm).offset;\n  const artMethodOffsets = getArtMethodSpec(vm).offset;\n\n  let offset;\n  Memory.patchCode(trampoline, 128, code => {\n    const writer = new X86Writer(code, { pc: trampoline });\n    const relocator = new X86Relocator(target, writer);\n\n    const fxsave = [0x0f, 0xae, 0x04, 0x24]; /* fxsave [esp] */\n    const fxrstor = [0x0f, 0xae, 0x0c, 0x24]; /* fxrstor [esp] */\n\n    // Save core args & callee-saves.\n    writer.putPushax();\n\n    writer.putMovRegReg('ebp', 'esp');\n\n    // Save FPRs + alignment padding.\n    writer.putAndRegU32('esp', 0xfffffff0);\n    writer.putSubRegImm('esp', 512);\n    writer.putBytes(fxsave);\n\n    writer.putMovRegFsU32Ptr('ebx', threadOffsets.self);\n    writer.putCallAddressWithAlignedArguments(artController.replacedMethods.findReplacementFromQuickCode, ['eax', 'ebx']);\n\n    writer.putTestRegReg('eax', 'eax');\n    writer.putJccShortLabel('je', 'restore_registers', 'no-hint');\n\n    // Set value of eax in the current frame.\n    writer.putMovRegOffsetPtrReg('ebp', 7 * 4, 'eax');\n\n    writer.putLabel('restore_registers');\n\n    // Restore FPRs.\n    writer.putBytes(fxrstor);\n\n    writer.putMovRegReg('esp', 'ebp');\n\n    // Restore core args & callee-saves.\n    writer.putPopax();\n\n    writer.putJccShortLabel('jne', 'invoke_replacement', 'no-hint');\n\n    do {\n      offset = relocator.readOne();\n    } while (offset < redirectSize && !relocator.eoi);\n\n    relocator.writeAll();\n\n    if (!relocator.eoi) {\n      writer.putJmpAddress(target.add(offset));\n    }\n\n    writer.putLabel('invoke_replacement');\n\n    writer.putJmpRegOffsetPtr('eax', artMethodOffsets.quickCode);\n\n    writer.flush();\n  });\n\n  return offset;\n}\n\nfunction writeArtQuickCodeReplacementTrampolineX64 (trampoline, target, redirectSize, constraints, vm) {\n  const threadOffsets = getArtThreadSpec(vm).offset;\n  const artMethodOffsets = getArtMethodSpec(vm).offset;\n\n  let offset;\n  Memory.patchCode(trampoline, 256, code => {\n    const writer = new X86Writer(code, { pc: trampoline });\n    const relocator = new X86Relocator(target, writer);\n\n    const fxsave = [0x0f, 0xae, 0x04, 0x24]; /* fxsave [rsp] */\n    const fxrstor = [0x0f, 0xae, 0x0c, 0x24]; /* fxrstor [rsp] */\n\n    // Save core args & callee-saves.\n    writer.putPushax();\n\n    writer.putMovRegReg('rbp', 'rsp');\n\n    // Save FPRs + alignment padding.\n    writer.putAndRegU32('rsp', 0xfffffff0);\n    writer.putSubRegImm('rsp', 512);\n    writer.putBytes(fxsave);\n\n    writer.putMovRegGsU32Ptr('rbx', threadOffsets.self);\n    writer.putCallAddressWithAlignedArguments(artController.replacedMethods.findReplacementFromQuickCode, ['rdi', 'rbx']);\n\n    writer.putTestRegReg('rax', 'rax');\n    writer.putJccShortLabel('je', 'restore_registers', 'no-hint');\n\n    // Set value of rdi in the current frame.\n    writer.putMovRegOffsetPtrReg('rbp', 8 * 8, 'rax');\n\n    writer.putLabel('restore_registers');\n\n    // Restore FPRs.\n    writer.putBytes(fxrstor);\n\n    writer.putMovRegReg('rsp', 'rbp');\n\n    // Restore core args & callee-saves.\n    writer.putPopax();\n\n    writer.putJccShortLabel('jne', 'invoke_replacement', 'no-hint');\n\n    do {\n      offset = relocator.readOne();\n    } while (offset < redirectSize && !relocator.eoi);\n\n    relocator.writeAll();\n\n    if (!relocator.eoi) {\n      writer.putJmpAddress(target.add(offset));\n    }\n\n    writer.putLabel('invoke_replacement');\n\n    writer.putJmpRegOffsetPtr('rdi', artMethodOffsets.quickCode);\n\n    writer.flush();\n  });\n\n  return offset;\n}\n\nfunction writeArtQuickCodeReplacementTrampolineArm (trampoline, target, redirectSize, constraints, vm) {\n  const artMethodOffsets = getArtMethodSpec(vm).offset;\n\n  const targetAddress = target.and(THUMB_BIT_REMOVAL_MASK);\n\n  let offset;\n  Memory.patchCode(trampoline, 128, code => {\n    const writer = new ThumbWriter(code, { pc: trampoline });\n    const relocator = new ThumbRelocator(targetAddress, writer);\n\n    const vpushFpRegs = [0x2d, 0xed, 0x10, 0x0a]; /* vpush {s0-s15} */\n    const vpopFpRegs = [0xbd, 0xec, 0x10, 0x0a]; /* vpop {s0-s15} */\n\n    // Save core args, callee-saves, LR.\n    writer.putPushRegs([\n      'r1',\n      'r2',\n      'r3',\n      'r5',\n      'r6',\n      'r7',\n      'r8',\n      'r10',\n      'r11',\n      'lr'\n    ]);\n\n    // Save FPRs.\n    writer.putBytes(vpushFpRegs);\n\n    // Save ArtMethod* + alignment padding.\n    writer.putSubRegRegImm('sp', 'sp', 8);\n    writer.putStrRegRegOffset('r0', 'sp', 0);\n\n    writer.putCallAddressWithArguments(artController.replacedMethods.findReplacementFromQuickCode, ['r0', 'r9']);\n\n    writer.putCmpRegImm('r0', 0);\n    writer.putBCondLabel('eq', 'restore_registers');\n\n    // Set value of r0 in the current frame.\n    writer.putStrRegRegOffset('r0', 'sp', 0);\n\n    writer.putLabel('restore_registers');\n\n    // Restore ArtMethod*\n    writer.putLdrRegRegOffset('r0', 'sp', 0);\n    writer.putAddRegRegImm('sp', 'sp', 8);\n\n    // Restore FPRs.\n    writer.putBytes(vpopFpRegs);\n\n    // Restore LR, callee-saves & core args.\n    writer.putPopRegs([\n      'lr',\n      'r11',\n      'r10',\n      'r8',\n      'r7',\n      'r6',\n      'r5',\n      'r3',\n      'r2',\n      'r1'\n    ]);\n\n    writer.putBCondLabel('ne', 'invoke_replacement');\n\n    do {\n      offset = relocator.readOne();\n    } while (offset < redirectSize && !relocator.eoi);\n\n    relocator.writeAll();\n\n    if (!relocator.eoi) {\n      writer.putLdrRegAddress('pc', target.add(offset));\n    }\n\n    writer.putLabel('invoke_replacement');\n\n    writer.putLdrRegRegOffset('pc', 'r0', artMethodOffsets.quickCode);\n\n    writer.flush();\n  });\n\n  return offset;\n}\n\nfunction writeArtQuickCodeReplacementTrampolineArm64 (trampoline, target, redirectSize, { availableScratchRegs }, vm) {\n  const artMethodOffsets = getArtMethodSpec(vm).offset;\n\n  let offset;\n  Memory.patchCode(trampoline, 256, code => {\n    const writer = new Arm64Writer(code, { pc: trampoline });\n    const relocator = new Arm64Relocator(target, writer);\n\n    // Save FPRs.\n    writer.putPushRegReg('d0', 'd1');\n    writer.putPushRegReg('d2', 'd3');\n    writer.putPushRegReg('d4', 'd5');\n    writer.putPushRegReg('d6', 'd7');\n\n    // Save core args, callee-saves & LR.\n    writer.putPushRegReg('x1', 'x2');\n    writer.putPushRegReg('x3', 'x4');\n    writer.putPushRegReg('x5', 'x6');\n    writer.putPushRegReg('x7', 'x20');\n    writer.putPushRegReg('x21', 'x22');\n    writer.putPushRegReg('x23', 'x24');\n    writer.putPushRegReg('x25', 'x26');\n    writer.putPushRegReg('x27', 'x28');\n    writer.putPushRegReg('x29', 'lr');\n\n    // Save ArtMethod* + alignment padding.\n    writer.putSubRegRegImm('sp', 'sp', 16);\n    writer.putStrRegRegOffset('x0', 'sp', 0);\n\n    writer.putCallAddressWithArguments(artController.replacedMethods.findReplacementFromQuickCode, ['x0', 'x19']);\n\n    writer.putCmpRegReg('x0', 'xzr');\n    writer.putBCondLabel('eq', 'restore_registers');\n\n    // Set value of x0 in the current frame.\n    writer.putStrRegRegOffset('x0', 'sp', 0);\n\n    writer.putLabel('restore_registers');\n\n    // Restore ArtMethod*\n    writer.putLdrRegRegOffset('x0', 'sp', 0);\n    writer.putAddRegRegImm('sp', 'sp', 16);\n\n    // Restore core args, callee-saves & LR.\n    writer.putPopRegReg('x29', 'lr');\n    writer.putPopRegReg('x27', 'x28');\n    writer.putPopRegReg('x25', 'x26');\n    writer.putPopRegReg('x23', 'x24');\n    writer.putPopRegReg('x21', 'x22');\n    writer.putPopRegReg('x7', 'x20');\n    writer.putPopRegReg('x5', 'x6');\n    writer.putPopRegReg('x3', 'x4');\n    writer.putPopRegReg('x1', 'x2');\n\n    // Restore FPRs.\n    writer.putPopRegReg('d6', 'd7');\n    writer.putPopRegReg('d4', 'd5');\n    writer.putPopRegReg('d2', 'd3');\n    writer.putPopRegReg('d0', 'd1');\n\n    writer.putBCondLabel('ne', 'invoke_replacement');\n\n    do {\n      offset = relocator.readOne();\n    } while (offset < redirectSize && !relocator.eoi);\n\n    relocator.writeAll();\n\n    if (!relocator.eoi) {\n      const scratchReg = Array.from(availableScratchRegs)[0];\n      writer.putLdrRegAddress(scratchReg, target.add(offset));\n      writer.putBrReg(scratchReg);\n    }\n\n    writer.putLabel('invoke_replacement');\n\n    writer.putLdrRegRegOffset('x16', 'x0', artMethodOffsets.quickCode);\n    writer.putBrReg('x16');\n\n    writer.flush();\n  });\n\n  return offset;\n}\n\nconst artQuickCodePrologueWriters = {\n  ia32: writeArtQuickCodePrologueX86,\n  x64: writeArtQuickCodePrologueX86,\n  arm: writeArtQuickCodePrologueArm,\n  arm64: writeArtQuickCodePrologueArm64\n};\n\nfunction writeArtQuickCodePrologueX86 (target, trampoline, redirectSize) {\n  Memory.patchCode(target, 16, code => {\n    const writer = new X86Writer(code, { pc: target });\n\n    writer.putJmpAddress(trampoline);\n    writer.flush();\n  });\n}\n\nfunction writeArtQuickCodePrologueArm (target, trampoline, redirectSize) {\n  const targetAddress = target.and(THUMB_BIT_REMOVAL_MASK);\n\n  Memory.patchCode(targetAddress, 16, code => {\n    const writer = new ThumbWriter(code, { pc: targetAddress });\n\n    writer.putLdrRegAddress('pc', trampoline.or(1));\n    writer.flush();\n  });\n}\n\nfunction writeArtQuickCodePrologueArm64 (target, trampoline, redirectSize) {\n  Memory.patchCode(target, 16, code => {\n    const writer = new Arm64Writer(code, { pc: target });\n\n    if (redirectSize === 16) {\n      writer.putLdrRegAddress('x16', trampoline);\n    } else {\n      writer.putAdrpRegAddress('x16', trampoline);\n    }\n\n    writer.putBrReg('x16');\n\n    writer.flush();\n  });\n}\n\nconst artQuickCodeHookRedirectSize = {\n  ia32: 5,\n  x64: 16,\n  arm: 8,\n  arm64: 16\n};\n\nclass ArtQuickCodeInterceptor {\n  constructor (quickCode) {\n    this.quickCode = quickCode;\n    this.quickCodeAddress = (Process.arch === 'arm')\n      ? quickCode.and(THUMB_BIT_REMOVAL_MASK)\n      : quickCode;\n\n    this.redirectSize = 0;\n    this.trampoline = null;\n    this.overwrittenPrologue = null;\n    this.overwrittenPrologueLength = 0;\n  }\n\n  _canRelocateCode (relocationSize, constraints) {\n    const Writer = thunkWriters[Process.arch];\n    const Relocator = thunkRelocators[Process.arch];\n\n    const { quickCodeAddress } = this;\n\n    const writer = new Writer(quickCodeAddress);\n    const relocator = new Relocator(quickCodeAddress, writer);\n\n    let offset;\n    if (Process.arch === 'arm64') {\n      let availableScratchRegs = new Set(['x16', 'x17']);\n\n      do {\n        const nextOffset = relocator.readOne();\n\n        const nextScratchRegs = new Set(availableScratchRegs);\n        const { read, written } = relocator.input.regsAccessed;\n        for (const regs of [read, written]) {\n          for (const reg of regs) {\n            let name;\n            if (reg.startsWith('w')) {\n              name = 'x' + reg.substring(1);\n            } else {\n              name = reg;\n            }\n            nextScratchRegs.delete(name);\n          }\n        }\n        if (nextScratchRegs.size === 0) {\n          break;\n        }\n\n        offset = nextOffset;\n        availableScratchRegs = nextScratchRegs;\n      } while (offset < relocationSize && !relocator.eoi);\n\n      constraints.availableScratchRegs = availableScratchRegs;\n    } else {\n      do {\n        offset = relocator.readOne();\n      } while (offset < relocationSize && !relocator.eoi);\n    }\n\n    return offset >= relocationSize;\n  }\n\n  _allocateTrampoline () {\n    if (trampolineAllocator === null) {\n      const trampolineSize = (pointerSize === 4) ? 128 : 256;\n      trampolineAllocator = makeCodeAllocator(trampolineSize);\n    }\n\n    const maxRedirectSize = artQuickCodeHookRedirectSize[Process.arch];\n\n    let redirectSize, spec;\n    let alignment = 1;\n    const constraints = {};\n    if (pointerSize === 4 || this._canRelocateCode(maxRedirectSize, constraints)) {\n      redirectSize = maxRedirectSize;\n\n      spec = {};\n    } else {\n      let maxDistance;\n      if (Process.arch === 'x64') {\n        redirectSize = 5;\n        maxDistance = X86_JMP_MAX_DISTANCE;\n      } else if (Process.arch === 'arm64') {\n        redirectSize = 8;\n        maxDistance = ARM64_ADRP_MAX_DISTANCE;\n        alignment = 4096;\n      }\n\n      spec = { near: this.quickCodeAddress, maxDistance };\n    }\n\n    this.redirectSize = redirectSize;\n    this.trampoline = trampolineAllocator.allocateSlice(spec, alignment);\n\n    return constraints;\n  }\n\n  _destroyTrampoline () {\n    trampolineAllocator.freeSlice(this.trampoline);\n  }\n\n  activate (vm) {\n    const constraints = this._allocateTrampoline();\n\n    const { trampoline, quickCode, redirectSize } = this;\n\n    const writeTrampoline = artQuickCodeReplacementTrampolineWriters[Process.arch];\n    const prologueLength = writeTrampoline(trampoline, quickCode, redirectSize, constraints, vm);\n    this.overwrittenPrologueLength = prologueLength;\n\n    this.overwrittenPrologue = Memory.dup(this.quickCodeAddress, prologueLength);\n\n    const writePrologue = artQuickCodePrologueWriters[Process.arch];\n    writePrologue(quickCode, trampoline, redirectSize);\n  }\n\n  deactivate () {\n    const { quickCodeAddress, overwrittenPrologueLength: prologueLength } = this;\n\n    const Writer = thunkWriters[Process.arch];\n    Memory.patchCode(quickCodeAddress, prologueLength, code => {\n      const writer = new Writer(code, { pc: quickCodeAddress });\n\n      const { overwrittenPrologue } = this;\n\n      writer.putBytes(overwrittenPrologue.readByteArray(prologueLength));\n      writer.flush();\n    });\n\n    this._destroyTrampoline();\n  }\n}\n\nfunction isArtQuickEntrypoint (address) {\n  const api = getApi();\n\n  const { module: m, artClassLinker } = api;\n\n  return address.equals(artClassLinker.quickGenericJniTrampoline) ||\n      address.equals(artClassLinker.quickToInterpreterBridgeTrampoline) ||\n      address.equals(artClassLinker.quickResolutionTrampoline) ||\n      address.equals(artClassLinker.quickImtConflictTrampoline) ||\n      (address.compare(m.base) >= 0 && address.compare(m.base.add(m.size)) < 0);\n}\n\nclass ArtMethodMangler {\n  constructor (opaqueMethodId) {\n    const methodId = unwrapMethodId(opaqueMethodId);\n\n    this.methodId = methodId;\n    this.originalMethod = null;\n    this.hookedMethodId = methodId;\n    this.replacementMethodId = null;\n\n    this.interceptor = null;\n  }\n\n  replace (impl, isInstanceMethod, argTypes, vm, api) {\n    const { kAccCompileDontBother, artNterpEntryPoint } = api;\n\n    this.originalMethod = fetchArtMethod(this.methodId, vm);\n\n    const originalFlags = this.originalMethod.accessFlags;\n\n    if ((originalFlags & kAccXposedHookedMethod) !== 0 && xposedIsSupported()) {\n      const hookInfo = this.originalMethod.jniCode;\n      this.hookedMethodId = hookInfo.add(2 * pointerSize).readPointer();\n      this.originalMethod = fetchArtMethod(this.hookedMethodId, vm);\n    }\n\n    const { hookedMethodId } = this;\n\n    const replacementMethodId = cloneArtMethod(hookedMethodId, vm);\n    this.replacementMethodId = replacementMethodId;\n\n    patchArtMethod(replacementMethodId, {\n      jniCode: impl,\n      accessFlags: ((originalFlags & ~(kAccCriticalNative | kAccFastNative | kAccNterpEntryPointFastPathFlag)) | kAccNative | kAccCompileDontBother) >>> 0,\n      quickCode: api.artClassLinker.quickGenericJniTrampoline,\n      interpreterCode: api.artInterpreterToCompiledCodeBridge\n    }, vm);\n\n    // Remove kAccFastInterpreterToInterpreterInvoke and kAccSkipAccessChecks to disable use_fast_path\n    // in interpreter_common.h\n    let hookedMethodRemovedFlags = kAccFastInterpreterToInterpreterInvoke | kAccSingleImplementation | kAccNterpEntryPointFastPathFlag;\n    if ((originalFlags & kAccNative) === 0) {\n      hookedMethodRemovedFlags |= kAccSkipAccessChecks;\n    }\n\n    patchArtMethod(hookedMethodId, {\n      accessFlags: ((originalFlags & ~(hookedMethodRemovedFlags)) | kAccCompileDontBother) >>> 0\n    }, vm);\n\n    const quickCode = this.originalMethod.quickCode;\n\n    // Replace Nterp quick entrypoints with art_quick_to_interpreter_bridge to force stepping out\n    // of ART's next-generation interpreter and use the quick stub instead.\n    if (artNterpEntryPoint !== undefined && quickCode.equals(artNterpEntryPoint)) {\n      patchArtMethod(hookedMethodId, {\n        quickCode: api.artQuickToInterpreterBridge\n      }, vm);\n    }\n\n    if (!isArtQuickEntrypoint(quickCode)) {\n      const interceptor = new ArtQuickCodeInterceptor(quickCode);\n      interceptor.activate(vm);\n\n      this.interceptor = interceptor;\n    }\n\n    artController.replacedMethods.set(hookedMethodId, replacementMethodId);\n\n    notifyArtMethodHooked(hookedMethodId, vm);\n  }\n\n  revert (vm) {\n    const { hookedMethodId, interceptor } = this;\n\n    patchArtMethod(hookedMethodId, this.originalMethod, vm);\n\n    artController.replacedMethods.delete(hookedMethodId);\n\n    if (interceptor !== null) {\n      interceptor.deactivate();\n\n      this.interceptor = null;\n    }\n  }\n\n  resolveTarget (wrapper, isInstanceMethod, env, api) {\n    return this.hookedMethodId;\n  }\n}\n\nfunction xposedIsSupported () {\n  return getAndroidApiLevel() < 28;\n}\n\nfunction fetchArtMethod (methodId, vm) {\n  const artMethodSpec = getArtMethodSpec(vm);\n  const artMethodOffset = artMethodSpec.offset;\n  return (['jniCode', 'accessFlags', 'quickCode', 'interpreterCode']\n    .reduce((original, name) => {\n      const offset = artMethodOffset[name];\n      if (offset === undefined) {\n        return original;\n      }\n      const address = methodId.add(offset);\n      const read = (name === 'accessFlags') ? readU32 : readPointer;\n      original[name] = read.call(address);\n      return original;\n    }, {}));\n}\n\nfunction patchArtMethod (methodId, patches, vm) {\n  const artMethodSpec = getArtMethodSpec(vm);\n  const artMethodOffset = artMethodSpec.offset;\n  Object.keys(patches).forEach(name => {\n    const offset = artMethodOffset[name];\n    if (offset === undefined) {\n      return;\n    }\n    const address = methodId.add(offset);\n    const write = (name === 'accessFlags') ? writeU32 : writePointer;\n    write.call(address, patches[name]);\n  });\n}\n\nclass DalvikMethodMangler {\n  constructor (methodId) {\n    this.methodId = methodId;\n    this.originalMethod = null;\n  }\n\n  replace (impl, isInstanceMethod, argTypes, vm, api) {\n    const { methodId } = this;\n\n    this.originalMethod = Memory.dup(methodId, DVM_METHOD_SIZE);\n\n    let argsSize = argTypes.reduce((acc, t) => (acc + t.size), 0);\n    if (isInstanceMethod) {\n      argsSize++;\n    }\n\n    /*\n     * make method native (with kAccNative)\n     * insSize and registersSize are set to arguments size\n     */\n    const accessFlags = (methodId.add(DVM_METHOD_OFFSET_ACCESS_FLAGS).readU32() | kAccNative) >>> 0;\n    const registersSize = argsSize;\n    const outsSize = 0;\n    const insSize = argsSize;\n\n    methodId.add(DVM_METHOD_OFFSET_ACCESS_FLAGS).writeU32(accessFlags);\n    methodId.add(DVM_METHOD_OFFSET_REGISTERS_SIZE).writeU16(registersSize);\n    methodId.add(DVM_METHOD_OFFSET_OUTS_SIZE).writeU16(outsSize);\n    methodId.add(DVM_METHOD_OFFSET_INS_SIZE).writeU16(insSize);\n    methodId.add(DVM_METHOD_OFFSET_JNI_ARG_INFO).writeU32(computeDalvikJniArgInfo(methodId));\n\n    api.dvmUseJNIBridge(methodId, impl);\n  }\n\n  revert (vm) {\n    Memory.copy(this.methodId, this.originalMethod, DVM_METHOD_SIZE);\n  }\n\n  resolveTarget (wrapper, isInstanceMethod, env, api) {\n    const thread = env.handle.add(DVM_JNI_ENV_OFFSET_SELF).readPointer();\n\n    let objectPtr;\n    if (isInstanceMethod) {\n      objectPtr = api.dvmDecodeIndirectRef(thread, wrapper.$h);\n    } else {\n      const h = wrapper.$borrowClassHandle(env);\n      objectPtr = api.dvmDecodeIndirectRef(thread, h.value);\n      h.unref(env);\n    }\n\n    let classObject;\n    if (isInstanceMethod) {\n      classObject = objectPtr.add(DVM_OBJECT_OFFSET_CLAZZ).readPointer();\n    } else {\n      classObject = objectPtr;\n    }\n\n    const classKey = classObject.toString(16);\n    let entry = patchedClasses.get(classKey);\n    if (entry === undefined) {\n      const vtablePtr = classObject.add(DVM_CLASS_OBJECT_OFFSET_VTABLE);\n      const vtableCountPtr = classObject.add(DVM_CLASS_OBJECT_OFFSET_VTABLE_COUNT);\n      const vtable = vtablePtr.readPointer();\n      const vtableCount = vtableCountPtr.readS32();\n\n      const vtableSize = vtableCount * pointerSize;\n      const shadowVtable = Memory.alloc(2 * vtableSize);\n      Memory.copy(shadowVtable, vtable, vtableSize);\n      vtablePtr.writePointer(shadowVtable);\n\n      entry = {\n        classObject,\n        vtablePtr,\n        vtableCountPtr,\n        vtable,\n        vtableCount,\n        shadowVtable,\n        shadowVtableCount: vtableCount,\n        targetMethods: new Map()\n      };\n      patchedClasses.set(classKey, entry);\n    }\n\n    const methodKey = this.methodId.toString(16);\n    let targetMethod = entry.targetMethods.get(methodKey);\n    if (targetMethod === undefined) {\n      targetMethod = Memory.dup(this.originalMethod, DVM_METHOD_SIZE);\n\n      const methodIndex = entry.shadowVtableCount++;\n      entry.shadowVtable.add(methodIndex * pointerSize).writePointer(targetMethod);\n      targetMethod.add(DVM_METHOD_OFFSET_METHOD_INDEX).writeU16(methodIndex);\n      entry.vtableCountPtr.writeS32(entry.shadowVtableCount);\n\n      entry.targetMethods.set(methodKey, targetMethod);\n    }\n\n    return targetMethod;\n  }\n}\n\nfunction computeDalvikJniArgInfo (methodId) {\n  if (Process.arch !== 'ia32') {\n    return DALVIK_JNI_NO_ARG_INFO;\n  }\n\n  // For the x86 ABI, valid hints should always be generated.\n  const shorty = methodId.add(DVM_METHOD_OFFSET_SHORTY).readPointer().readCString();\n  if (shorty === null || shorty.length === 0 || shorty.length > 0xffff) {\n    return DALVIK_JNI_NO_ARG_INFO;\n  }\n\n  let returnType;\n  switch (shorty[0]) {\n    case 'V':\n      returnType = DALVIK_JNI_RETURN_VOID;\n      break;\n    case 'F':\n      returnType = DALVIK_JNI_RETURN_FLOAT;\n      break;\n    case 'D':\n      returnType = DALVIK_JNI_RETURN_DOUBLE;\n      break;\n    case 'J':\n      returnType = DALVIK_JNI_RETURN_S8;\n      break;\n    case 'Z':\n    case 'B':\n      returnType = DALVIK_JNI_RETURN_S1;\n      break;\n    case 'C':\n      returnType = DALVIK_JNI_RETURN_U2;\n      break;\n    case 'S':\n      returnType = DALVIK_JNI_RETURN_S2;\n      break;\n    default:\n      returnType = DALVIK_JNI_RETURN_S4;\n      break;\n  }\n\n  let hints = 0;\n  for (let i = shorty.length - 1; i > 0; i--) {\n    const ch = shorty[i];\n    hints += (ch === 'D' || ch === 'J') ? 2 : 1;\n  }\n\n  return (returnType << DALVIK_JNI_RETURN_SHIFT) | hints;\n}\n\nfunction cloneArtMethod (method, vm) {\n  const api = getApi();\n\n  if (getAndroidApiLevel() < 23) {\n    const thread = api['art::Thread::CurrentFromGdb']();\n    return api['art::mirror::Object::Clone'](method, thread);\n  }\n\n  return Memory.dup(method, getArtMethodSpec(vm).size);\n}\n\nfunction deoptimizeMethod (vm, env, method) {\n  requestDeoptimization(vm, env, kSelectiveDeoptimization, method);\n}\n\nfunction deoptimizeEverything (vm, env) {\n  requestDeoptimization(vm, env, kFullDeoptimization);\n}\n\nfunction deoptimizeBootImage (vm, env) {\n  const api = getApi();\n\n  if (getAndroidApiLevel() < 26) {\n    throw new Error('This API is only available on Android >= 8.0');\n  }\n\n  withRunnableArtThread(vm, env, thread => {\n    api['art::Runtime::DeoptimizeBootImage'](api.artRuntime);\n  });\n}\n\nfunction requestDeoptimization (vm, env, kind, method) {\n  const api = getApi();\n\n  if (getAndroidApiLevel() < 24) {\n    throw new Error('This API is only available on Android >= 7.0');\n  }\n\n  withRunnableArtThread(vm, env, thread => {\n    if (getAndroidApiLevel() < 30) {\n      if (!api.isJdwpStarted()) {\n        const session = startJdwp(api);\n        jdwpSessions.push(session);\n      }\n\n      if (!api.isDebuggerActive()) {\n        api['art::Dbg::GoActive']();\n      }\n\n      const request = Memory.alloc(8 + pointerSize);\n      request.writeU32(kind);\n\n      switch (kind) {\n        case kFullDeoptimization:\n          break;\n        case kSelectiveDeoptimization:\n          request.add(8).writePointer(method);\n          break;\n        default:\n          throw new Error('Unsupported deoptimization kind');\n      }\n\n      api['art::Dbg::RequestDeoptimization'](request);\n\n      api['art::Dbg::ManageDeoptimization']();\n    } else {\n      const instrumentation = api.artInstrumentation;\n      if (instrumentation === null) {\n        throw new Error('Unable to find Instrumentation class in ART; please file a bug');\n      }\n\n      const enableDeopt = api['art::Instrumentation::EnableDeoptimization'];\n      if (enableDeopt !== undefined) {\n        const deoptimizationEnabled = !!instrumentation.add(getArtInstrumentationSpec().offset.deoptimizationEnabled).readU8();\n        if (!deoptimizationEnabled) {\n          enableDeopt(instrumentation);\n        }\n      }\n\n      switch (kind) {\n        case kFullDeoptimization:\n          api['art::Instrumentation::DeoptimizeEverything'](instrumentation, Memory.allocUtf8String('frida'));\n          break;\n        case kSelectiveDeoptimization:\n          api['art::Instrumentation::Deoptimize'](instrumentation, method);\n          break;\n        default:\n          throw new Error('Unsupported deoptimization kind');\n      }\n    }\n  });\n}\n\nclass JdwpSession {\n  constructor () {\n    /*\n     * We partially stub out the ADB JDWP transport to ensure we always\n     * succeed in starting JDWP. Failure will crash the process.\n     */\n    const acceptImpl = Module.getExportByName('libart.so', '_ZN3art4JDWP12JdwpAdbState6AcceptEv');\n    const receiveClientFdImpl = Module.getExportByName('libart.so', '_ZN3art4JDWP12JdwpAdbState15ReceiveClientFdEv');\n\n    const controlPair = makeSocketPair();\n    const clientPair = makeSocketPair();\n\n    this._controlFd = controlPair[0];\n    this._clientFd = clientPair[0];\n\n    let acceptListener = null;\n    acceptListener = Interceptor.attach(acceptImpl, function (args) {\n      const state = args[0];\n\n      const controlSockPtr = Memory.scanSync(state.add(8252), 256, '00 ff ff ff ff 00')[0].address.add(1);\n\n      /*\n       * This will make JdwpAdbState::Accept() skip the control socket() and connect(),\n       * and skip right to calling ReceiveClientFd(), replaced below.\n       */\n      controlSockPtr.writeS32(controlPair[1]);\n\n      acceptListener.detach();\n    });\n\n    Interceptor.replace(receiveClientFdImpl, new NativeCallback(function (state) {\n      Interceptor.revert(receiveClientFdImpl);\n\n      return clientPair[1];\n    }, 'int', ['pointer']));\n\n    Interceptor.flush();\n\n    this._handshakeRequest = this._performHandshake();\n  }\n\n  async _performHandshake () {\n    const input = new UnixInputStream(this._clientFd, { autoClose: false });\n    const output = new UnixOutputStream(this._clientFd, { autoClose: false });\n\n    const handshakePacket = [0x4a, 0x44, 0x57, 0x50, 0x2d, 0x48, 0x61, 0x6e, 0x64, 0x73, 0x68, 0x61, 0x6b, 0x65];\n    try {\n      await output.writeAll(handshakePacket);\n      await input.readAll(handshakePacket.length);\n    } catch (e) {\n    }\n  }\n}\n\nfunction startJdwp (api) {\n  const session = new JdwpSession();\n\n  api['art::Dbg::SetJdwpAllowed'](1);\n\n  const options = makeJdwpOptions();\n  api['art::Dbg::ConfigureJdwp'](options);\n\n  const startDebugger = api['art::InternalDebuggerControlCallback::StartDebugger'];\n  if (startDebugger !== undefined) {\n    startDebugger(NULL);\n  } else {\n    api['art::Dbg::StartJdwp']();\n  }\n\n  return session;\n}\n\nfunction makeJdwpOptions () {\n  const kJdwpTransportAndroidAdb = getAndroidApiLevel() < 28 ? 2 : 3;\n  const kJdwpPortFirstAvailable = 0;\n\n  const transport = kJdwpTransportAndroidAdb;\n  const server = true;\n  const suspend = false;\n  const port = kJdwpPortFirstAvailable;\n\n  const size = 8 + STD_STRING_SIZE + 2;\n  const result = Memory.alloc(size);\n  result\n    .writeU32(transport).add(4)\n    .writeU8(server ? 1 : 0).add(1)\n    .writeU8(suspend ? 1 : 0).add(1)\n    .add(STD_STRING_SIZE) // We leave `host` zeroed, i.e. empty string\n    .writeU16(port);\n  return result;\n}\n\nfunction makeSocketPair () {\n  if (socketpair === null) {\n    socketpair = new NativeFunction(\n      Module.getExportByName('libc.so', 'socketpair'),\n      'int',\n      ['int', 'int', 'int', 'pointer']);\n  }\n\n  const buf = Memory.alloc(8);\n  if (socketpair(AF_UNIX, SOCK_STREAM, 0, buf) === -1) {\n    throw new Error('Unable to create socketpair for JDWP');\n  }\n\n  return [\n    buf.readS32(),\n    buf.add(4).readS32()\n  ];\n}\n\nfunction makeAddGlobalRefFallbackForAndroid5 (api) {\n  const offset = getArtVMSpec().offset;\n  const lock = api.vm.add(offset.globalsLock);\n  const table = api.vm.add(offset.globals);\n\n  const add = api['art::IndirectReferenceTable::Add'];\n  const acquire = api['art::ReaderWriterMutex::ExclusiveLock'];\n  const release = api['art::ReaderWriterMutex::ExclusiveUnlock'];\n\n  const IRT_FIRST_SEGMENT = 0;\n\n  return function (vm, thread, obj) {\n    acquire(lock, thread);\n    try {\n      return add(table, IRT_FIRST_SEGMENT, obj);\n    } finally {\n      release(lock, thread);\n    }\n  };\n}\n\nfunction makeDecodeGlobalFallback (api) {\n  /*\n   * Fallback for art::JavaVMExt::DecodeGlobal, which is\n   * unavailable in Android versions <= 5 and >= 15.\n   */\n  const decode = api['art::Thread::DecodeJObject'];\n  if (decode === undefined) {\n    throw new Error('art::Thread::DecodeJObject is not available; please file a bug');\n  }\n\n  return function (vm, thread, ref) {\n    return decode(thread, ref);\n  };\n}\n\n/*\n * In order to call internal ART APIs we need to transition our native thread's\n * art::Thread to the proper state. The ScopedObjectAccess (SOA) helper that ART\n * uses internally is what we would like to use to accomplish this goal.\n *\n * There is however a challenge. The SOA implementation is fully inlined, so\n * we cannot just allocate a chunk of memory and call its constructor and\n * destructor to get the desired setup and teardown.\n *\n * We could however precompile such code using a C++ compiler, but considering\n * how many versions of ART we would need to compile it for, multiplied by the\n * number of supported architectures, we really don't want to go there.\n *\n * Reimplementing it in JavaScript is not desirable either, as we would need\n * to keep track of even more internals prone to change as ART evolves.\n *\n * So our least terrible option is to find a really simple C++ method in ART\n * that sets up a SOA object, performs as few and distinct operations as\n * possible, and then returns. If we clone that implementation we can swap\n * out the few/distinct operations with our own.\n *\n * We can accomplish this by using Frida's relocator API, and detecting the\n * few/distinct operations happening between setup and teardown of the scope.\n * We skip those when making our copy and instead put a call to a NativeCallback\n * there. Our NativeCallback is thus able to call internal ART APIs safely.\n *\n * The ExceptionClear() implementation that's part of the JNIEnv's vtable is\n * a perfect fit, as all it does is clear one field of the art::Thread.\n * (Except on older versions where it also clears a bit more... but still\n * pretty simple.)\n *\n * However, checked JNI might be enabled, making ExceptionClear() a bit more\n * complex, and essentially a wrapper around the unchecked version.\n *\n * One last thing to note is that we also look up the address of FatalError(),\n * as ExceptionClear() typically ends with a __stack_chk_fail() noreturn call\n * that's followed by the next JNIEnv vtable method, FatalError(). We don't want\n * to recompile its code as well, so we try to detect it. There might however be\n * padding between the two functions, which we need to ignore. Ideally we would\n * know that the call is to __stack_chk_fail(), so we can stop at that point,\n * but detecting that isn't trivial.\n */\n\nconst threadStateTransitionRecompilers = {\n  ia32: recompileExceptionClearForX86,\n  x64: recompileExceptionClearForX86,\n  arm: recompileExceptionClearForArm,\n  arm64: recompileExceptionClearForArm64\n};\n\nfunction makeArtThreadStateTransitionImpl (vm, env, callback) {\n  const envVtable = env.handle.readPointer();\n  let exceptionClearImpl = envVtable.add(ENV_VTABLE_OFFSET_EXCEPTION_CLEAR).readPointer();\n  const nextFuncImpl = envVtable.add(ENV_VTABLE_OFFSET_FATAL_ERROR).readPointer();\n\n  if (Process.arch === 'arm64') {\n    const size = 0x150;\n    const pattern = \"c0 03 5f d6\"; ///ret\n    if (Memory.scanSync(exceptionClearImpl, size, pattern).length > 0) {\n      exceptionClearImpl = envVtable.add(ENV_VTABLE_OFFSET_EXCEPTION_CLEAR_ALT).readPointer();\n    }\n  }\n\n  const recompile = threadStateTransitionRecompilers[Process.arch];\n  if (recompile === undefined) {\n    throw new Error('Not yet implemented for ' + Process.arch);\n  }\n\n  let perform = null;\n\n  const threadOffsets = getArtThreadSpec(vm).offset;\n\n  const exceptionOffset = threadOffsets.exception;\n\n  const neuteredOffsets = new Set();\n  const isReportedOffset = threadOffsets.isExceptionReportedToInstrumentation;\n  if (isReportedOffset !== null) {\n    neuteredOffsets.add(isReportedOffset);\n  }\n  const throwLocationStartOffset = threadOffsets.throwLocation;\n  if (throwLocationStartOffset !== null) {\n    neuteredOffsets.add(throwLocationStartOffset);\n    neuteredOffsets.add(throwLocationStartOffset + pointerSize);\n    neuteredOffsets.add(throwLocationStartOffset + (2 * pointerSize));\n  }\n\n  const codeSize = 65536;\n  const code = Memory.alloc(codeSize);\n  Memory.patchCode(code, codeSize, buffer => {\n    perform = recompile(buffer, code, exceptionClearImpl, nextFuncImpl, exceptionOffset, neuteredOffsets, callback);\n  });\n\n  perform._code = code;\n  perform._callback = callback;\n\n  return perform;\n}\n\nfunction recompileExceptionClearForX86 (buffer, pc, exceptionClearImpl, nextFuncImpl, exceptionOffset, neuteredOffsets, callback) {\n  const blocks = {};\n  const branchTargets = new Set();\n\n  const pending = [exceptionClearImpl];\n  while (pending.length > 0) {\n    let current = pending.shift();\n\n    const alreadyCovered = Object.values(blocks).some(({ begin, end }) => current.compare(begin) >= 0 && current.compare(end) < 0);\n    if (alreadyCovered) {\n      continue;\n    }\n\n    const blockAddressKey = current.toString();\n\n    let block = {\n      begin: current\n    };\n    let lastInsn = null;\n\n    let reachedEndOfBlock = false;\n    do {\n      if (current.equals(nextFuncImpl)) {\n        reachedEndOfBlock = true;\n        break;\n      }\n\n      const insn = Instruction.parse(current);\n      lastInsn = insn;\n\n      const existingBlock = blocks[insn.address.toString()];\n      if (existingBlock !== undefined) {\n        delete blocks[existingBlock.begin.toString()];\n        blocks[blockAddressKey] = existingBlock;\n        existingBlock.begin = block.begin;\n        block = null;\n        break;\n      }\n\n      let branchTarget = null;\n      switch (insn.mnemonic) {\n        case 'jmp':\n          branchTarget = ptr(insn.operands[0].value);\n          reachedEndOfBlock = true;\n          break;\n        case 'je':\n        case 'jg':\n        case 'jle':\n        case 'jne':\n        case 'js':\n          branchTarget = ptr(insn.operands[0].value);\n          break;\n        case 'ret':\n          reachedEndOfBlock = true;\n          break;\n      }\n\n      if (branchTarget !== null) {\n        branchTargets.add(branchTarget.toString());\n\n        pending.push(branchTarget);\n        pending.sort((a, b) => a.compare(b));\n      }\n\n      current = insn.next;\n    } while (!reachedEndOfBlock);\n\n    if (block !== null) {\n      block.end = lastInsn.address.add(lastInsn.size);\n      blocks[blockAddressKey] = block;\n    }\n  }\n\n  const blocksOrdered = Object.keys(blocks).map(key => blocks[key]);\n  blocksOrdered.sort((a, b) => a.begin.compare(b.begin));\n\n  const entryBlock = blocks[exceptionClearImpl.toString()];\n  blocksOrdered.splice(blocksOrdered.indexOf(entryBlock), 1);\n  blocksOrdered.unshift(entryBlock);\n\n  const writer = new X86Writer(buffer, { pc });\n\n  let foundCore = false;\n  let threadReg = null;\n\n  blocksOrdered.forEach(block => {\n    const size = block.end.sub(block.begin).toInt32();\n\n    const relocator = new X86Relocator(block.begin, writer);\n\n    let offset;\n    while ((offset = relocator.readOne()) !== 0) {\n      const insn = relocator.input;\n      const { mnemonic } = insn;\n\n      const insnAddressId = insn.address.toString();\n      if (branchTargets.has(insnAddressId)) {\n        writer.putLabel(insnAddressId);\n      }\n\n      let keep = true;\n\n      switch (mnemonic) {\n        case 'jmp':\n          writer.putJmpNearLabel(branchLabelFromOperand(insn.operands[0]));\n          keep = false;\n          break;\n        case 'je':\n        case 'jg':\n        case 'jle':\n        case 'jne':\n        case 'js':\n          writer.putJccNearLabel(mnemonic, branchLabelFromOperand(insn.operands[0]), 'no-hint');\n          keep = false;\n          break;\n        /*\n         * JNI::ExceptionClear(), when checked JNI is off.\n         */\n        case 'mov': {\n          const [dst, src] = insn.operands;\n\n          if (dst.type === 'mem' && src.type === 'imm') {\n            const dstValue = dst.value;\n            const dstOffset = dstValue.disp;\n\n            if (dstOffset === exceptionOffset && src.value.valueOf() === 0) {\n              threadReg = dstValue.base;\n\n              writer.putPushfx();\n              writer.putPushax();\n              writer.putMovRegReg('xbp', 'xsp');\n              if (pointerSize === 4) {\n                writer.putAndRegU32('esp', 0xfffffff0);\n              } else {\n                const scratchReg = (threadReg !== 'rdi') ? 'rdi' : 'rsi';\n                writer.putMovRegU64(scratchReg, uint64('0xfffffffffffffff0'));\n                writer.putAndRegReg('rsp', scratchReg);\n              }\n              writer.putCallAddressWithAlignedArguments(callback, [threadReg]);\n              writer.putMovRegReg('xsp', 'xbp');\n              writer.putPopax();\n              writer.putPopfx();\n\n              foundCore = true;\n              keep = false;\n            } else if (neuteredOffsets.has(dstOffset) && dstValue.base === threadReg) {\n              keep = false;\n            }\n          }\n\n          break;\n        }\n        /*\n         * CheckJNI::ExceptionClear, when checked JNI is on. Wrapper that calls JNI::ExceptionClear().\n         */\n        case 'call': {\n          const target = insn.operands[0];\n          if (target.type === 'mem' && target.value.disp === ENV_VTABLE_OFFSET_EXCEPTION_CLEAR) {\n            /*\n             * Get art::Thread * from JNIEnv *\n             */\n            if (pointerSize === 4) {\n              writer.putPopReg('eax');\n              writer.putMovRegRegOffsetPtr('eax', 'eax', 4);\n              writer.putPushReg('eax');\n            } else {\n              writer.putMovRegRegOffsetPtr('rdi', 'rdi', 8);\n            }\n\n            writer.putCallAddressWithArguments(callback, []);\n\n            foundCore = true;\n            keep = false;\n          }\n\n          break;\n        }\n      }\n\n      if (keep) {\n        relocator.writeAll();\n      } else {\n        relocator.skipOne();\n      }\n\n      if (offset === size) {\n        break;\n      }\n    }\n\n    relocator.dispose();\n  });\n\n  writer.dispose();\n\n  if (!foundCore) {\n    throwThreadStateTransitionParseError();\n  }\n\n  return new NativeFunction(pc, 'void', ['pointer'], nativeFunctionOptions);\n}\n\nfunction recompileExceptionClearForArm (buffer, pc, exceptionClearImpl, nextFuncImpl, exceptionOffset, neuteredOffsets, callback) {\n  const blocks = {};\n  const branchTargets = new Set();\n\n  const thumbBitRemovalMask = ptr(1).not();\n\n  const pending = [exceptionClearImpl];\n  while (pending.length > 0) {\n    let current = pending.shift();\n\n    const alreadyCovered = Object.values(blocks).some(({ begin, end }) => current.compare(begin) >= 0 && current.compare(end) < 0);\n    if (alreadyCovered) {\n      continue;\n    }\n\n    const begin = current.and(thumbBitRemovalMask);\n    const blockId = begin.toString();\n    const thumbBit = current.and(1);\n\n    let block = {\n      begin\n    };\n    let lastInsn = null;\n\n    let reachedEndOfBlock = false;\n    let ifThenBlockRemaining = 0;\n    do {\n      if (current.equals(nextFuncImpl)) {\n        reachedEndOfBlock = true;\n        break;\n      }\n\n      const insn = Instruction.parse(current);\n      const { mnemonic } = insn;\n      lastInsn = insn;\n\n      const currentAddress = current.and(thumbBitRemovalMask);\n      const insnId = currentAddress.toString();\n\n      const existingBlock = blocks[insnId];\n      if (existingBlock !== undefined) {\n        delete blocks[existingBlock.begin.toString()];\n        blocks[blockId] = existingBlock;\n        existingBlock.begin = block.begin;\n        block = null;\n        break;\n      }\n\n      const isOutsideIfThenBlock = ifThenBlockRemaining === 0;\n\n      let branchTarget = null;\n\n      switch (mnemonic) {\n        case 'b':\n          branchTarget = ptr(insn.operands[0].value);\n          reachedEndOfBlock = isOutsideIfThenBlock;\n          break;\n        case 'beq.w':\n        case 'beq':\n        case 'bne':\n        case 'bgt':\n          branchTarget = ptr(insn.operands[0].value);\n          break;\n        case 'cbz':\n        case 'cbnz':\n          branchTarget = ptr(insn.operands[1].value);\n          break;\n        case 'pop.w':\n          if (isOutsideIfThenBlock) {\n            reachedEndOfBlock = insn.operands.filter(op => op.value === 'pc').length === 1;\n          }\n          break;\n      }\n\n      switch (mnemonic) {\n        case 'it':\n          ifThenBlockRemaining = 1;\n          break;\n        case 'itt':\n          ifThenBlockRemaining = 2;\n          break;\n        case 'ittt':\n          ifThenBlockRemaining = 3;\n          break;\n        case 'itttt':\n          ifThenBlockRemaining = 4;\n          break;\n        default:\n          if (ifThenBlockRemaining > 0) {\n            ifThenBlockRemaining--;\n          }\n          break;\n      }\n\n      if (branchTarget !== null) {\n        branchTargets.add(branchTarget.toString());\n\n        pending.push(branchTarget.or(thumbBit));\n        pending.sort((a, b) => a.compare(b));\n      }\n\n      current = insn.next;\n    } while (!reachedEndOfBlock);\n\n    if (block !== null) {\n      block.end = lastInsn.address.add(lastInsn.size);\n      blocks[blockId] = block;\n    }\n  }\n\n  const blocksOrdered = Object.keys(blocks).map(key => blocks[key]);\n  blocksOrdered.sort((a, b) => a.begin.compare(b.begin));\n\n  const entryBlock = blocks[exceptionClearImpl.and(thumbBitRemovalMask).toString()];\n  blocksOrdered.splice(blocksOrdered.indexOf(entryBlock), 1);\n  blocksOrdered.unshift(entryBlock);\n\n  const writer = new ThumbWriter(buffer, { pc });\n\n  let foundCore = false;\n  let threadReg = null;\n  let realImplReg = null;\n\n  blocksOrdered.forEach(block => {\n    const relocator = new ThumbRelocator(block.begin, writer);\n\n    let address = block.begin;\n    const end = block.end;\n    let size = 0;\n    do {\n      const offset = relocator.readOne();\n      if (offset === 0) {\n        throw new Error('Unexpected end of block');\n      }\n      const insn = relocator.input;\n      address = insn.address;\n      size = insn.size;\n      const { mnemonic } = insn;\n\n      const insnAddressId = address.toString();\n      if (branchTargets.has(insnAddressId)) {\n        writer.putLabel(insnAddressId);\n      }\n\n      let keep = true;\n\n      switch (mnemonic) {\n        case 'b':\n          writer.putBLabel(branchLabelFromOperand(insn.operands[0]));\n          keep = false;\n          break;\n        case 'beq.w':\n          writer.putBCondLabelWide('eq', branchLabelFromOperand(insn.operands[0]));\n          keep = false;\n          break;\n        case 'beq':\n        case 'bne':\n        case 'bgt':\n          writer.putBCondLabelWide(mnemonic.substr(1), branchLabelFromOperand(insn.operands[0]));\n          keep = false;\n          break;\n        case 'cbz': {\n          const ops = insn.operands;\n          writer.putCbzRegLabel(ops[0].value, branchLabelFromOperand(ops[1]));\n          keep = false;\n          break;\n        }\n        case 'cbnz': {\n          const ops = insn.operands;\n          writer.putCbnzRegLabel(ops[0].value, branchLabelFromOperand(ops[1]));\n          keep = false;\n          break;\n        }\n        /*\n         * JNI::ExceptionClear(), when checked JNI is off.\n         */\n        case 'str':\n        case 'str.w': {\n          const dstValue = insn.operands[1].value;\n          const dstOffset = dstValue.disp;\n\n          if (dstOffset === exceptionOffset) {\n            threadReg = dstValue.base;\n\n            const nzcvqReg = (threadReg !== 'r4') ? 'r4' : 'r5';\n            const clobberedRegs = ['r0', 'r1', 'r2', 'r3', nzcvqReg, 'r9', 'r12', 'lr'];\n\n            writer.putPushRegs(clobberedRegs);\n            writer.putMrsRegReg(nzcvqReg, 'apsr-nzcvq');\n\n            writer.putCallAddressWithArguments(callback, [threadReg]);\n\n            writer.putMsrRegReg('apsr-nzcvq', nzcvqReg);\n            writer.putPopRegs(clobberedRegs);\n\n            foundCore = true;\n            keep = false;\n          } else if (neuteredOffsets.has(dstOffset) && dstValue.base === threadReg) {\n            keep = false;\n          }\n\n          break;\n        }\n        /*\n         * CheckJNI::ExceptionClear, when checked JNI is on. Wrapper that calls JNI::ExceptionClear().\n         */\n        case 'ldr': {\n          const [dstOp, srcOp] = insn.operands;\n\n          if (srcOp.type === 'mem') {\n            const src = srcOp.value;\n\n            if (src.base[0] === 'r' && src.disp === ENV_VTABLE_OFFSET_EXCEPTION_CLEAR) {\n              realImplReg = dstOp.value;\n            }\n          }\n\n          break;\n        }\n        case 'blx':\n          if (insn.operands[0].value === realImplReg) {\n            writer.putLdrRegRegOffset('r0', 'r0', 4); // Get art::Thread * from JNIEnv *\n            writer.putCallAddressWithArguments(callback, ['r0']);\n\n            foundCore = true;\n            realImplReg = null;\n            keep = false;\n          }\n\n          break;\n      }\n\n      if (keep) {\n        relocator.writeAll();\n      } else {\n        relocator.skipOne();\n      }\n    } while (!address.add(size).equals(end));\n\n    relocator.dispose();\n  });\n\n  writer.dispose();\n\n  if (!foundCore) {\n    throwThreadStateTransitionParseError();\n  }\n\n  return new NativeFunction(pc.or(1), 'void', ['pointer'], nativeFunctionOptions);\n}\n\nfunction recompileExceptionClearForArm64 (buffer, pc, exceptionClearImpl, nextFuncImpl, exceptionOffset, neuteredOffsets, callback) {\n  const blocks = {};\n  const branchTargets = new Set();\n\n  const pending = [exceptionClearImpl];\n  while (pending.length > 0) {\n    let current = pending.shift();\n\n    const alreadyCovered = Object.values(blocks).some(({ begin, end }) => current.compare(begin) >= 0 && current.compare(end) < 0);\n    if (alreadyCovered) {\n      continue;\n    }\n\n    const blockAddressKey = current.toString();\n\n    let block = {\n      begin: current\n    };\n    let lastInsn = null;\n\n    let reachedEndOfBlock = false;\n    do {\n      if (current.equals(nextFuncImpl)) {\n        reachedEndOfBlock = true;\n        break;\n      }\n\n      let insn;\n      try {\n        insn = Instruction.parse(current);\n      } catch (e) {\n        if (current.readU32() === 0x00000000) {\n          reachedEndOfBlock = true;\n          break;\n        } else {\n          throw e;\n        }\n      }\n      lastInsn = insn;\n\n      const existingBlock = blocks[insn.address.toString()];\n      if (existingBlock !== undefined) {\n        delete blocks[existingBlock.begin.toString()];\n        blocks[blockAddressKey] = existingBlock;\n        existingBlock.begin = block.begin;\n        block = null;\n        break;\n      }\n\n      let branchTarget = null;\n      switch (insn.mnemonic) {\n        case 'b':\n          branchTarget = ptr(insn.operands[0].value);\n          reachedEndOfBlock = true;\n          break;\n        case 'b.eq':\n        case 'b.ne':\n        case 'b.le':\n        case 'b.gt':\n          branchTarget = ptr(insn.operands[0].value);\n          break;\n        case 'cbz':\n        case 'cbnz':\n          branchTarget = ptr(insn.operands[1].value);\n          break;\n        case 'tbz':\n        case 'tbnz':\n          branchTarget = ptr(insn.operands[2].value);\n          break;\n        case 'ret':\n          reachedEndOfBlock = true;\n          break;\n      }\n\n      if (branchTarget !== null) {\n        branchTargets.add(branchTarget.toString());\n\n        pending.push(branchTarget);\n        pending.sort((a, b) => a.compare(b));\n      }\n\n      current = insn.next;\n    } while (!reachedEndOfBlock);\n\n    if (block !== null) {\n      block.end = lastInsn.address.add(lastInsn.size);\n      blocks[blockAddressKey] = block;\n    }\n  }\n\n  const blocksOrdered = Object.keys(blocks).map(key => blocks[key]);\n  blocksOrdered.sort((a, b) => a.begin.compare(b.begin));\n\n  const entryBlock = blocks[exceptionClearImpl.toString()];\n  blocksOrdered.splice(blocksOrdered.indexOf(entryBlock), 1);\n  blocksOrdered.unshift(entryBlock);\n\n  const writer = new Arm64Writer(buffer, { pc });\n\n  writer.putBLabel('performTransition');\n\n  const invokeCallback = pc.add(writer.offset);\n  writer.putPushAllXRegisters();\n  writer.putCallAddressWithArguments(callback, ['x0']);\n  writer.putPopAllXRegisters();\n  writer.putRet();\n\n  writer.putLabel('performTransition');\n\n  let foundCore = false;\n  let threadReg = null;\n  let realImplReg = null;\n\n  blocksOrdered.forEach(block => {\n    const size = block.end.sub(block.begin).toInt32();\n\n    const relocator = new Arm64Relocator(block.begin, writer);\n\n    let offset;\n    while ((offset = relocator.readOne()) !== 0) {\n      const insn = relocator.input;\n      const { mnemonic } = insn;\n\n      const insnAddressId = insn.address.toString();\n      if (branchTargets.has(insnAddressId)) {\n        writer.putLabel(insnAddressId);\n      }\n\n      let keep = true;\n\n      switch (mnemonic) {\n        case 'b':\n          writer.putBLabel(branchLabelFromOperand(insn.operands[0]));\n          keep = false;\n          break;\n        case 'b.eq':\n        case 'b.ne':\n        case 'b.le':\n        case 'b.gt':\n          writer.putBCondLabel(mnemonic.substr(2), branchLabelFromOperand(insn.operands[0]));\n          keep = false;\n          break;\n        case 'cbz': {\n          const ops = insn.operands;\n          writer.putCbzRegLabel(ops[0].value, branchLabelFromOperand(ops[1]));\n          keep = false;\n          break;\n        }\n        case 'cbnz': {\n          const ops = insn.operands;\n          writer.putCbnzRegLabel(ops[0].value, branchLabelFromOperand(ops[1]));\n          keep = false;\n          break;\n        }\n        case 'tbz': {\n          const ops = insn.operands;\n          writer.putTbzRegImmLabel(ops[0].value, ops[1].value.valueOf(), branchLabelFromOperand(ops[2]));\n          keep = false;\n          break;\n        }\n        case 'tbnz': {\n          const ops = insn.operands;\n          writer.putTbnzRegImmLabel(ops[0].value, ops[1].value.valueOf(), branchLabelFromOperand(ops[2]));\n          keep = false;\n          break;\n        }\n        /*\n         * JNI::ExceptionClear(), when checked JNI is off.\n         */\n        case 'str': {\n          const ops = insn.operands;\n          const srcReg = ops[0].value;\n          const dstValue = ops[1].value;\n          const dstOffset = dstValue.disp;\n\n          if (srcReg === 'xzr' && dstOffset === exceptionOffset) {\n            threadReg = dstValue.base;\n\n            writer.putPushRegReg('x0', 'lr');\n            writer.putMovRegReg('x0', threadReg);\n            writer.putBlImm(invokeCallback);\n            writer.putPopRegReg('x0', 'lr');\n\n            foundCore = true;\n            keep = false;\n          } else if (neuteredOffsets.has(dstOffset) && dstValue.base === threadReg) {\n            keep = false;\n          }\n\n          break;\n        }\n        /*\n         * CheckJNI::ExceptionClear, when checked JNI is on. Wrapper that calls JNI::ExceptionClear().\n         */\n        case 'ldr': {\n          const ops = insn.operands;\n\n          const src = ops[1].value;\n          if (src.base[0] === 'x' && src.disp === ENV_VTABLE_OFFSET_EXCEPTION_CLEAR) {\n            realImplReg = ops[0].value;\n          }\n\n          break;\n        }\n        case 'blr':\n          if (insn.operands[0].value === realImplReg) {\n            writer.putLdrRegRegOffset('x0', 'x0', 8); // Get art::Thread * from JNIEnv *\n            writer.putCallAddressWithArguments(callback, ['x0']);\n\n            foundCore = true;\n            realImplReg = null;\n            keep = false;\n          }\n\n          break;\n      }\n\n      if (keep) {\n        relocator.writeAll();\n      } else {\n        relocator.skipOne();\n      }\n\n      if (offset === size) {\n        break;\n      }\n    }\n\n    relocator.dispose();\n  });\n\n  writer.dispose();\n\n  if (!foundCore) {\n    throwThreadStateTransitionParseError();\n  }\n\n  return new NativeFunction(pc, 'void', ['pointer'], nativeFunctionOptions);\n}\n\nfunction throwThreadStateTransitionParseError () {\n  throw new Error('Unable to parse ART internals; please file a bug');\n}\n\nfunction fixupArtQuickDeliverExceptionBug (api) {\n  const prettyMethod = api['art::ArtMethod::PrettyMethod'];\n  if (prettyMethod === undefined) {\n    return;\n  }\n\n  /*\n   * There is a bug in art::Thread::QuickDeliverException() where it assumes\n   * there is a Java stack frame present on the art::Thread's stack. This is\n   * not the case if a native thread calls a throwing method like FindClass().\n   *\n   * We work around this bug here by detecting when method->PrettyMethod()\n   * happens with method == nullptr.\n   */\n  Interceptor.attach(prettyMethod.impl, artController.hooks.ArtMethod.prettyMethod);\n  Interceptor.flush();\n}\n\nfunction branchLabelFromOperand (op) {\n  return ptr(op.value).toString();\n}\n\nfunction makeCxxMethodWrapperReturningPointerByValueGeneric (address, argTypes) {\n  return new NativeFunction(address, 'pointer', argTypes, nativeFunctionOptions);\n}\n\nfunction makeCxxMethodWrapperReturningPointerByValueInFirstArg (address, argTypes) {\n  const impl = new NativeFunction(address, 'void', ['pointer'].concat(argTypes), nativeFunctionOptions);\n  return function () {\n    const resultPtr = Memory.alloc(pointerSize);\n    impl(resultPtr, ...arguments);\n    return resultPtr.readPointer();\n  };\n}\n\nfunction makeCxxMethodWrapperReturningStdStringByValue (impl, argTypes) {\n  const { arch } = Process;\n  switch (arch) {\n    case 'ia32':\n    case 'arm64': {\n      let thunk;\n      if (arch === 'ia32') {\n        thunk = makeThunk(64, writer => {\n          const argCount = 1 + argTypes.length;\n          const argvSize = argCount * 4;\n          writer.putSubRegImm('esp', argvSize);\n          for (let i = 0; i !== argCount; i++) {\n            const offset = i * 4;\n            writer.putMovRegRegOffsetPtr('eax', 'esp', argvSize + 4 + offset);\n            writer.putMovRegOffsetPtrReg('esp', offset, 'eax');\n          }\n          writer.putCallAddress(impl);\n          writer.putAddRegImm('esp', argvSize - 4);\n          writer.putRet();\n        });\n      } else {\n        thunk = makeThunk(32, writer => {\n          writer.putMovRegReg('x8', 'x0');\n          argTypes.forEach((t, i) => {\n            writer.putMovRegReg('x' + i, 'x' + (i + 1));\n          });\n          writer.putLdrRegAddress('x7', impl);\n          writer.putBrReg('x7');\n        });\n      }\n\n      const invokeThunk = new NativeFunction(thunk, 'void', ['pointer'].concat(argTypes), nativeFunctionOptions);\n      const wrapper = function (...args) {\n        invokeThunk(...args);\n      };\n      wrapper.handle = thunk;\n      wrapper.impl = impl;\n      return wrapper;\n    }\n    default: {\n      const result = new NativeFunction(impl, 'void', ['pointer'].concat(argTypes), nativeFunctionOptions);\n      result.impl = impl;\n      return result;\n    }\n  }\n}\n\nclass StdString {\n  constructor () {\n    this.handle = Memory.alloc(STD_STRING_SIZE);\n  }\n\n  dispose () {\n    const [data, isTiny] = this._getData();\n    if (!isTiny) {\n      getApi().$delete(data);\n    }\n  }\n\n  disposeToString () {\n    const result = this.toString();\n    this.dispose();\n    return result;\n  }\n\n  toString () {\n    const [data] = this._getData();\n    return data.readUtf8String();\n  }\n\n  _getData () {\n    const str = this.handle;\n    const isTiny = (str.readU8() & 1) === 0;\n    const data = isTiny ? str.add(1) : str.add(2 * pointerSize).readPointer();\n    return [data, isTiny];\n  }\n}\n\nclass StdVector {\n  $delete () {\n    this.dispose();\n    getApi().$delete(this);\n  }\n\n  constructor (storage, elementSize) {\n    this.handle = storage;\n\n    this._begin = storage;\n    this._end = storage.add(pointerSize);\n    this._storage = storage.add(2 * pointerSize);\n\n    this._elementSize = elementSize;\n  }\n\n  init () {\n    this.begin = NULL;\n    this.end = NULL;\n    this.storage = NULL;\n  }\n\n  dispose () {\n    getApi().$delete(this.begin);\n  }\n\n  get begin () {\n    return this._begin.readPointer();\n  }\n\n  set begin (value) {\n    this._begin.writePointer(value);\n  }\n\n  get end () {\n    return this._end.readPointer();\n  }\n\n  set end (value) {\n    this._end.writePointer(value);\n  }\n\n  get storage () {\n    return this._storage.readPointer();\n  }\n\n  set storage (value) {\n    this._storage.writePointer(value);\n  }\n\n  get size () {\n    return this.end.sub(this.begin).toInt32() / this._elementSize;\n  }\n}\n\nclass HandleVector extends StdVector {\n  static $new () {\n    const vector = new HandleVector(getApi().$new(STD_VECTOR_SIZE));\n    vector.init();\n    return vector;\n  }\n\n  constructor (storage) {\n    super(storage, pointerSize);\n  }\n\n  get handles () {\n    const result = [];\n\n    let cur = this.begin;\n    const end = this.end;\n    while (!cur.equals(end)) {\n      result.push(cur.readPointer());\n      cur = cur.add(pointerSize);\n    }\n\n    return result;\n  }\n}\n\nconst BHS_OFFSET_LINK = 0;\nconst BHS_OFFSET_NUM_REFS = pointerSize;\nconst BHS_SIZE = BHS_OFFSET_NUM_REFS + 4;\n\nconst kNumReferencesVariableSized = -1;\n\nclass BaseHandleScope {\n  $delete () {\n    this.dispose();\n    getApi().$delete(this);\n  }\n\n  constructor (storage) {\n    this.handle = storage;\n\n    this._link = storage.add(BHS_OFFSET_LINK);\n    this._numberOfReferences = storage.add(BHS_OFFSET_NUM_REFS);\n  }\n\n  init (link, numberOfReferences) {\n    this.link = link;\n    this.numberOfReferences = numberOfReferences;\n  }\n\n  dispose () {\n  }\n\n  get link () {\n    return new BaseHandleScope(this._link.readPointer());\n  }\n\n  set link (value) {\n    this._link.writePointer(value);\n  }\n\n  get numberOfReferences () {\n    return this._numberOfReferences.readS32();\n  }\n\n  set numberOfReferences (value) {\n    this._numberOfReferences.writeS32(value);\n  }\n}\n\nconst VSHS_OFFSET_SELF = alignPointerOffset(BHS_SIZE);\nconst VSHS_OFFSET_CURRENT_SCOPE = VSHS_OFFSET_SELF + pointerSize;\nconst VSHS_SIZE = VSHS_OFFSET_CURRENT_SCOPE + pointerSize;\n\nclass VariableSizedHandleScope extends BaseHandleScope {\n  static $new (thread, vm) {\n    const scope = new VariableSizedHandleScope(getApi().$new(VSHS_SIZE));\n    scope.init(thread, vm);\n    return scope;\n  }\n\n  constructor (storage) {\n    super(storage);\n\n    this._self = storage.add(VSHS_OFFSET_SELF);\n    this._currentScope = storage.add(VSHS_OFFSET_CURRENT_SCOPE);\n\n    const kLocalScopeSize = 64;\n    const kSizeOfReferencesPerScope = kLocalScopeSize - pointerSize - 4 - 4;\n    const kNumReferencesPerScope = kSizeOfReferencesPerScope / 4;\n    this._scopeLayout = FixedSizeHandleScope.layoutForCapacity(kNumReferencesPerScope);\n    this._topHandleScopePtr = null;\n  }\n\n  init (thread, vm) {\n    const topHandleScopePtr = thread.add(getArtThreadSpec(vm).offset.topHandleScope);\n    this._topHandleScopePtr = topHandleScopePtr;\n\n    super.init(topHandleScopePtr.readPointer(), kNumReferencesVariableSized);\n\n    this.self = thread;\n    this.currentScope = FixedSizeHandleScope.$new(this._scopeLayout);\n\n    topHandleScopePtr.writePointer(this);\n  }\n\n  dispose () {\n    this._topHandleScopePtr.writePointer(this.link);\n\n    let scope;\n    while ((scope = this.currentScope) !== null) {\n      const next = scope.link;\n      scope.$delete();\n      this.currentScope = next;\n    }\n  }\n\n  get self () {\n    return this._self.readPointer();\n  }\n\n  set self (value) {\n    this._self.writePointer(value);\n  }\n\n  get currentScope () {\n    const storage = this._currentScope.readPointer();\n    if (storage.isNull()) {\n      return null;\n    }\n    return new FixedSizeHandleScope(storage, this._scopeLayout);\n  }\n\n  set currentScope (value) {\n    this._currentScope.writePointer(value);\n  }\n\n  newHandle (object) {\n    return this.currentScope.newHandle(object);\n  }\n}\n\nclass FixedSizeHandleScope extends BaseHandleScope {\n  static $new (layout) {\n    const scope = new FixedSizeHandleScope(getApi().$new(layout.size), layout);\n    scope.init();\n    return scope;\n  }\n\n  constructor (storage, layout) {\n    super(storage);\n\n    const { offset } = layout;\n    this._refsStorage = storage.add(offset.refsStorage);\n    this._pos = storage.add(offset.pos);\n\n    this._layout = layout;\n  }\n\n  init () {\n    super.init(NULL, this._layout.numberOfReferences);\n\n    this.pos = 0;\n  }\n\n  get pos () {\n    return this._pos.readU32();\n  }\n\n  set pos (value) {\n    this._pos.writeU32(value);\n  }\n\n  newHandle (object) {\n    const pos = this.pos;\n    const handle = this._refsStorage.add(pos * 4);\n    handle.writeS32(object.toInt32());\n    this.pos = pos + 1;\n    return handle;\n  }\n\n  static layoutForCapacity (numRefs) {\n    const refsStorage = BHS_SIZE;\n    const pos = refsStorage + (numRefs * 4);\n\n    return {\n      size: pos + 4,\n      numberOfReferences: numRefs,\n      offset: {\n        refsStorage,\n        pos\n      }\n    };\n  }\n}\n\nconst objectVisitorPredicateFactories = {\n  arm: function (needle, onMatch) {\n    const size = Process.pageSize;\n\n    const predicate = Memory.alloc(size);\n\n    Memory.protect(predicate, size, 'rwx');\n\n    const onMatchCallback = new NativeCallback(onMatch, 'void', ['pointer']);\n    predicate._onMatchCallback = onMatchCallback;\n\n    const instructions = [\n      0x6801, // ldr r1, [r0]\n      0x4a03, // ldr r2, =needle\n      0x4291, // cmp r1, r2\n      0xd101, // bne mismatch\n      0x4b02, // ldr r3, =onMatch\n      0x4718, // bx r3\n      0x4770, // bx lr\n      0xbf00 // nop\n    ];\n    const needleOffset = instructions.length * 2;\n    const onMatchOffset = needleOffset + 4;\n    const codeSize = onMatchOffset + 4;\n\n    Memory.patchCode(predicate, codeSize, function (address) {\n      instructions.forEach((instruction, index) => {\n        address.add(index * 2).writeU16(instruction);\n      });\n      address.add(needleOffset).writeS32(needle);\n      address.add(onMatchOffset).writePointer(onMatchCallback);\n    });\n\n    return predicate.or(1);\n  },\n  arm64: function (needle, onMatch) {\n    const size = Process.pageSize;\n\n    const predicate = Memory.alloc(size);\n\n    Memory.protect(predicate, size, 'rwx');\n\n    const onMatchCallback = new NativeCallback(onMatch, 'void', ['pointer']);\n    predicate._onMatchCallback = onMatchCallback;\n\n    const instructions = [\n      0xb9400001, // ldr w1, [x0]\n      0x180000c2, // ldr w2, =needle\n      0x6b02003f, // cmp w1, w2\n      0x54000061, // b.ne mismatch\n      0x58000083, // ldr x3, =onMatch\n      0xd61f0060, // br x3\n      0xd65f03c0 // ret\n    ];\n    const needleOffset = instructions.length * 4;\n    const onMatchOffset = needleOffset + 4;\n    const codeSize = onMatchOffset + 8;\n\n    Memory.patchCode(predicate, codeSize, function (address) {\n      instructions.forEach((instruction, index) => {\n        address.add(index * 4).writeU32(instruction);\n      });\n      address.add(needleOffset).writeS32(needle);\n      address.add(onMatchOffset).writePointer(onMatchCallback);\n    });\n\n    return predicate;\n  }\n};\n\nfunction makeObjectVisitorPredicate (needle, onMatch) {\n  const factory = objectVisitorPredicateFactories[Process.arch] || makeGenericObjectVisitorPredicate;\n  return factory(needle, onMatch);\n}\n\nfunction makeGenericObjectVisitorPredicate (needle, onMatch) {\n  return new NativeCallback(object => {\n    const klass = object.readS32();\n    if (klass === needle) {\n      onMatch(object);\n    }\n  }, 'void', ['pointer', 'pointer']);\n}\n\nfunction alignPointerOffset (offset) {\n  const remainder = offset % pointerSize;\n  if (remainder !== 0) {\n    return offset + pointerSize - remainder;\n  }\n  return offset;\n}\n\nmodule.exports = {\n  getApi,\n  ensureClassInitialized,\n  getAndroidVersion,\n  getAndroidApiLevel,\n  getArtClassSpec,\n  getArtMethodSpec,\n  getArtFieldSpec,\n  getArtThreadSpec,\n  getArtThreadFromEnv,\n  withRunnableArtThread,\n  withAllArtThreadsSuspended,\n  makeArtClassVisitor,\n  makeArtClassLoaderVisitor,\n  ArtStackVisitor,\n  ArtMethod,\n  makeMethodMangler,\n  translateMethod,\n  backtrace,\n  revertGlobalPatches,\n  deoptimizeEverything,\n  deoptimizeBootImage,\n  deoptimizeMethod,\n  HandleVector,\n  VariableSizedHandleScope,\n  makeObjectVisitorPredicate,\n  DVM_JNI_ENV_OFFSET_SELF\n};\n", encoding="utf-8")
+        #subprocess.run("sed -i '/Interceptor.attach(prettyMethod.impl, artController.hooks.ArtMethod.prettyMethod);/,/Interceptor.flush();/{d}' %s" % (js_dir / "android.js"), shell=True)
+        subprocess.run("sed -i 's/Current thread is not attached to the Java VM; please move this code inside a Java.perform() callback/cUrrent th^ead 1s n0t attAched t0 tHe ja{a v3; p1ease m0ve th1s c0de 1ns1de a JbAb.perf0rm[] ca11back/g ' %s" % (js_dir / "vm.js"), shell=True)
 
     runtime_reldir = Path("runtime")
     runtime_srcdir = input_dir / runtime_reldir
diff --git a/bindings/gumjs/gumscriptscheduler.c b/bindings/gumjs/gumscriptscheduler.c
index b86a6c5..cc8c726 100644
--- a/bindings/gumjs/gumscriptscheduler.c
+++ b/bindings/gumjs/gumscriptscheduler.c
@@ -114,7 +114,7 @@ gum_script_scheduler_start (GumScriptScheduler * self)
   {
     self->js_loop = g_main_loop_new (self->js_context, TRUE);
 
-    self->js_thread = g_thread_new ("gum-js-loop",
+    self->js_thread = g_thread_new ("{FRIDA_PREFIX}-js-loop",
         (GThreadFunc) gum_script_scheduler_run_js_loop, self);
   }
 }
diff --git a/gum/gum.c b/gum/gum.c
index 239c70d..cd43aa7 100644
--- a/gum/gum.c
+++ b/gum/gum.c
@@ -306,7 +306,7 @@ gum_init_embedded (void)
   g_log_set_default_handler (gum_on_log_message, NULL);
   gum_do_init ();
 
-  g_set_prgname ("frida");
+  g_set_prgname ("{FRIDA_PREFIX}");
 
 #if defined (HAVE_LINUX) && defined (HAVE_GLIBC)
   gum_libdl_prevent_unload ();
-- 
2.47.0.windows.2

